### 索引和选择数据

Pandas对象的轴标签信息能够提供很多功能：

- 使用已知的索引器标识数据（例如：提供元数据），这在数据分析，可视化和交互式终端显示中很重要。
- 支持自动地、明确地数据对齐。
- 允许直观地获取、设置数据子集。

本章我们将聚焦在最后一点，即如何切片、切块、一般的获取和设置Pandas对象的子集，主要关注的是Series和DataFrame，因为它们在这个领域受到更多的开发关注。

> 注意：Python和Numpy的索引操作符`[]`提供了快速、简单的广泛使用的访问Pandas数据结构的方法。这使得交互式工作变得直观，因为如果已经知道如何使用Python字典和Numpy数组，几乎不需要学习什么新的东西。不过，因为待访问的数据的类型不会提前知道，直接使用标准的操作符有一些优化限制。在生产代码中，我们建议你优先使用本章中介绍的优化的Pandas数据访问方法。

> 警告：设置操作返回一个副本还是引用，可能取决于上下文。这有时称为`chained assignment`，并且应该避免。查看[Returning a View versus Copy](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-view-versus-copy)获得更多信息。

> 警告：使用浮点数对基于整数的索引进行索引的操作已在0.18.0版本中进行了说明，有关修改的摘要，请查看[这里](http://pandas.pydata.org/pandas-docs/version/0.23/whatsnew.html#whatsnew-0180-float-indexers)。

查看[MultiIndex / Advanced Indexing](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced)获得关于MultiIndex和更多的高级索引的文档。

查看 [cookbook](http://pandas.pydata.org/pandas-docs/version/0.23/cookbook.html#cookbook-selection)获得一些高级使用方法。

#### 12.1 不同的索引选择

对象选择操作已经有一些用户请求的添加，以支持更明确的基于位置的索引。Pandas现在支持三种多轴索引：

- `.loc`是主要的基于标签的索引方式。但是，也可以和布尔数组一起使用。当没有找到元素时，`.loc`将抛出`KeyError`。允许的输入有：

  - 单独的标签，比如`5`或`a`（注意：`5`会被解释为index标签，这种用法`不是`index 的整数位置）。
  - 标签列表或数组`['a', 'b', 'c', 'd']`。
  - 标签切片对象`'a':'f'`（注意：与通常的Python切片相反，在索引中使用时，包含开始和结束，查看[按标签索引](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-slicing-with-labels)）。
  - 布尔数组。
  - 单一参数（可调用的Series、DataFrame或Panel）、返回合法的支持索引的输出（上述几项中的一项）的可调用函数。

  查看[按标签选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-label)获得更多信息。

- `.iloc`是主要的基于位置（0到轴的长度-1）的索引方式。但是，也可以和布尔数组一起使用。如果请求的索引器超出了范围，`iloc`将会抛出`IndexError`，除非切片索引器允许越界索引。这符合Python或Numpy的切片语义。允许的输入有：

  - 整数，例如`5`。

  - 整数列表或数组：`[4, 3, 0]`。

  - 带有整数的切片对象：`1:7`。

  - 布尔数组。

  - 单一参数（可调用的Series、DataFrame或Panel）、返回合法的支持索引的输出（上述几项中的一项）的可调用函数。

    查看[按位置选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-integer)，[高级索引](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced)和[高级分层](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced-advanced-hierarchical)获得更多信息。

- `.loc`，`.iloc`和`[]`索引方式都接受一个可调用对象作为索引器。查看[按可调用对象选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-callable)获得更多信息。

从具有多轴选择的对象获取值使用以下符号（以使用`.loc`为例，使用`.iloc`也同样适用）。每个轴的访问器都有可能是空的切片`:`，未指定的轴为被假定为`:`，例如，`p.loc['a']`等价于`p.loc['a',:,:]`。

| 对象类型  | 索引器                                            |
| --------- | ------------------------------------------------- |
| Series    | `s.loc[indexer]`                                  |
| DataFrame | `df.loc[row_indexer,column_indexer]`              |
| Panel     | `p.loc[item_indexer,major_indexer,minor_indexer]` |

#### 12.2 基本操作

就像在介绍数据结构时的[最后一节](http://pandas.pydata.org/pandas-docs/version/0.23/basics.html#basics)中提到的，使用`[]`（对于熟悉在Python中实现类行为的人来说又称作`__getitem__`）索引的主要函数是选出低维切片。下面的表格展示了使用`[]`索引Pandas对象时的返回类型:

| 对象类型  | 选择              | 返回值类型               |
| --------- | ----------------- | ------------------------ |
| Series    | `series[label]`   | 标量值                   |
| DataFrame | `frame[colname]`  | 对应列名的Series         |
| Panel     | `panel[itemname]` | 对应 itemname的DataFrame |

我们构造了一个简单的时间序列数据集，来说明索引功能：

```python
In [1]: dates = pd.date_range('1/1/2000', periods=8)

In [2]: df = pd.DataFrame(np.random.randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])

In [3]: df
Out[3]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885

In [4]: panel = pd.Panel({'one' : df, 'two' : df - df.mean()})

In [5]: panel
Out[5]: 
<class 'pandas.core.panel.Panel'>
Dimensions: 2 (items) x 8 (major_axis) x 4 (minor_axis)
Items axis: one to two
Major_axis axis: 2000-01-01 00:00:00 to 2000-01-08 00:00:00
Minor_axis axis: A to D
```

> 注意：除非特别说明，否则索引功能都不是时间序列特有的。

因此，如上所述，我们使用`[]`进行大部分基本索引：

```python
In [6]: s = df['A']

In [7]: s[dates[5]]
Out[7]: -0.67368970808837059

In [8]: panel['two']
Out[8]: 
                   A         B         C         D
2000-01-01  0.409571  0.113086 -0.610826 -0.936507
2000-01-02  1.152571  0.222735  1.017442 -0.845111
2000-01-03 -0.921390 -1.708620  0.403304  1.270929
2000-01-04  0.662014 -0.310822 -0.141342  0.470985
2000-01-05 -0.484513  0.962970  1.174465 -0.888276
2000-01-06 -0.733231  0.509598 -0.580194  0.724113
2000-01-07  0.345164  0.972995 -0.816769 -0.840143
2000-01-08 -0.430188 -0.761943 -0.446079  1.044010
```

你可以传入列名组成的列表来按照顺序选择那些列。如果某个类没有包含的DataFrame中，会触发异常。也可以用这种方式设置多列。

```python
In [9]: df
Out[9]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885

In [10]: df[['B', 'A']] = df[['A', 'B']]

In [11]: df
Out[11]: 
                   A         B         C         D
2000-01-01 -0.282863  0.469112 -1.509059 -1.135632
2000-01-02 -0.173215  1.212112  0.119209 -1.044236
2000-01-03 -2.104569 -0.861849 -0.494929  1.071804
2000-01-04 -0.706771  0.721555 -1.039575  0.271860
2000-01-05  0.567020 -0.424972  0.276232 -1.087401
2000-01-06  0.113648 -0.673690 -1.478427  0.524988
2000-01-07  0.577046  0.404705 -1.715002 -1.039268
2000-01-08 -1.157892 -0.370647 -1.344312  0.844885
```

你可能发现，这在对列的子集进行就地变换时很有用。

> 警告：当使用`.loc`或`.iloc`设置Series或DataFrame时，Pandas会对齐所有轴。这不会修改`df`，因为对齐在赋值之前。
>
> ```pyhton
> In [12]: df[['A', 'B']]
> Out[12]: 
>                    A         B
> 2000-01-01 -0.282863  0.469112
> 2000-01-02 -0.173215  1.212112
> 2000-01-03 -2.104569 -0.861849
> 2000-01-04 -0.706771  0.721555
> 2000-01-05  0.567020 -0.424972
> 2000-01-06  0.113648 -0.673690
> 2000-01-07  0.577046  0.404705
> 2000-01-08 -1.157892 -0.370647
> 
> In [13]: df.loc[:,['B', 'A']] = df[['A', 'B']]
> 
> In [14]: df[['A', 'B']]
> Out[14]: 
>                    A         B
> 2000-01-01 -0.282863  0.469112
> 2000-01-02 -0.173215  1.212112
> 2000-01-03 -2.104569 -0.861849
> 2000-01-04 -0.706771  0.721555
> 2000-01-05  0.567020 -0.424972
> 2000-01-06  0.113648 -0.673690
> 2000-01-07  0.577046  0.404705
> 2000-01-08 -1.157892 -0.370647
> ```
>
> 正确的交换列值的方式是使用原始值：
>
> ```python
> In [15]: df.loc[:,['B', 'A']] = df[['A', 'B']].values
> 
> In [16]: df[['A', 'B']]
> Out[16]: 
>                    A         B
> 2000-01-01  0.469112 -0.282863
> 2000-01-02  1.212112 -0.173215
> 2000-01-03 -0.861849 -2.104569
> 2000-01-04  0.721555 -0.706771
> 2000-01-05 -0.424972  0.567020
> 2000-01-06 -0.673690  0.113648
> 2000-01-07  0.404705  0.577046
> 2000-01-08 -0.370647 -1.157892
> ```

#### 12.3 访问属性

你可能以访问属性的方式访问Series的索引，DataFrame的列和Panel的Item。

```python
In [17]: sa = pd.Series([1,2,3],index=list('abc'))

In [18]: dfa = df.copy()
```

```python
In [19]: sa.b
Out[19]: 2

In [20]: dfa.A
Out[20]: 
2000-01-01    0.469112
2000-01-02    1.212112
2000-01-03   -0.861849
2000-01-04    0.721555
2000-01-05   -0.424972
2000-01-06   -0.673690
2000-01-07    0.404705
2000-01-08   -0.370647
Freq: D, Name: A, dtype: float64

In [21]: panel.one
Out[21]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885
```

```python
In [22]: sa.a = 5

In [23]: sa
Out[23]: 
a    5
b    2
c    3
dtype: int64

In [24]: dfa.A = list(range(len(dfa.index)))  # ok if A already exists

In [25]: dfa
Out[25]: 
            A         B         C         D
2000-01-01  0 -0.282863 -1.509059 -1.135632
2000-01-02  1 -0.173215  0.119209 -1.044236
2000-01-03  2 -2.104569 -0.494929  1.071804
2000-01-04  3 -0.706771 -1.039575  0.271860
2000-01-05  4  0.567020  0.276232 -1.087401
2000-01-06  5  0.113648 -1.478427  0.524988
2000-01-07  6  0.577046 -1.715002 -1.039268
2000-01-08  7 -1.157892 -1.344312  0.844885

In [26]: dfa['A'] = list(range(len(dfa.index)))  # use this form to create a new column

In [27]: dfa
Out[27]: 
            A         B         C         D
2000-01-01  0 -0.282863 -1.509059 -1.135632
2000-01-02  1 -0.173215  0.119209 -1.044236
2000-01-03  2 -2.104569 -0.494929  1.071804
2000-01-04  3 -0.706771 -1.039575  0.271860
2000-01-05  4  0.567020  0.276232 -1.087401
2000-01-06  5  0.113648 -1.478427  0.524988
2000-01-07  6  0.577046 -1.715002 -1.039268
2000-01-08  7 -1.157892 -1.344312  0.844885
```

> 警告：
>
> - 只有索引元素是合法的Python识别码时才可以用这种方式访问。例如不允许使用`s.1`，查看[这里](https://docs.python.org/3/reference/lexical_analysis.html#identifiers)了解合法的识别码的解释。
> - 当属性和已经存在方法名冲突时，不能访问。例如不允许使用`s.min`。
> - 当属性和`index, major_axis, minor_axis, items`冲突时，也不能访问。
> - 上述几种情况，使用保准的索引方式都是可行的。例如`s['a']`，`s['min']`，`s['index']`会访问对应的元素或列。

如果你正在使用IPython环境，你可以使用`tab`自动补全功能来查看所有看访问的属性。

你也可以用一个字典为DataFrame的一行赋值。

```python
In [28]: x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})

In [29]: x.iloc[1] = dict(x=9, y=99)

In [30]: x
Out[30]: 
   x   y
0  1   3
1  9  99
2  3   5
```

你可以使用属性访问来修改一个已经存在的Series的元素或DataFrame的列，但是要注意，如果你尝试使用属性访问来创建一个新的列，它会创建一个新的属性，而不是一个新的列。在0.21.0及以后的版本，这将会抛出一个`UserWarning`。

```python
In[1]: df = pd.DataFrame({'one': [1., 2., 3.]})
In[2]: df.two = [4, 5, 6]
UserWarning: Pandas doesn't allow Series to be assigned into nonexistent columns - see https://pandas.pydata.org/pandas-docs/stable/indexing.html#attribute_access
In[3]: df
Out[3]:
   one
0  1.0
1  2.0
2  3.0
```

#### 12.4 切割范围

沿着任意轴切割范围的最稳健和一致的方法在[按位置选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-integer)的部分会介绍详细介绍`.iloc`方法。现在，我们解释一下使用`[]`操作符切片的语义。

对于Series，这个语法和Numpy数组的工作方式一样，返回Series的值的一部分和对应的标签。

```pyhton
In [31]: s[:5]
Out[31]: 
2000-01-01    0.469112
2000-01-02    1.212112
2000-01-03   -0.861849
2000-01-04    0.721555
2000-01-05   -0.424972
Freq: D, Name: A, dtype: float64

In [32]: s[::2]
Out[32]: 
2000-01-01    0.469112
2000-01-03   -0.861849
2000-01-05   -0.424972
2000-01-07    0.404705
Freq: 2D, Name: A, dtype: float64

In [33]: s[::-1]
Out[33]: 
2000-01-08   -0.370647
2000-01-07    0.404705
2000-01-06   -0.673690
2000-01-05   -0.424972
2000-01-04    0.721555
2000-01-03   -0.861849
2000-01-02    1.212112
2000-01-01    0.469112
Freq: -1D, Name: A, dtype: float64
```

注意，设置操作同样也可以工作

```python
In [34]: s2 = s.copy()

In [35]: s2[:5] = 0

In [36]: s2
Out[36]: 
2000-01-01    0.000000
2000-01-02    0.000000
2000-01-03    0.000000
2000-01-04    0.000000
2000-01-05    0.000000
2000-01-06   -0.673690
2000-01-07    0.404705
2000-01-08   -0.370647
Freq: D, Name: A, dtype: float64
```

对应DataFrame，`[]`的内部切片是在切割行。这主要是为了方便，因为这是非常常见的操作。

```python
In [37]: df[:3]
Out[37]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804

In [38]: df[::-1]
Out[38]: 
                   A         B         C         D
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
```

#### 12.5 使用标签选择

> 警告：设置操作返回一个副本还是引用，可能取决于上下文。这有时称为`chained assignment`，并且应该避免。查看[Returning a View versus Copy](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-view-versus-copy)获得更多信息。

> 警告：当使用的的切片器和索引类型不兼容（或可转换）时，`.loc`是严格的。例如，在DatatimeIndex中使用整数，这将抛出`TypeError`。
>
> ```python
> In [39]: dfl = pd.DataFrame(np.random.randn(5,4), columns=list('ABCD'), index=pd.date_range('20130101',periods=5))
> 
> In [40]: dfl
> Out[40]: 
>                    A         B         C         D
> 2013-01-01  1.075770 -0.109050  1.643563 -1.469388
> 2013-01-02  0.357021 -0.674600 -1.776904 -0.968914
> 2013-01-03 -1.294524  0.413738  0.276662 -0.472035
> 2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061
> 2013-01-05  0.895717  0.805244 -1.206412  2.565646
> ```
>
> ```python
> In [4]: dfl.loc[2:3]
> TypeError: cannot do slice indexing on <class 'pandas.tseries.index.DatetimeIndex'> with these indexers [2] of <type 'int'>
> ```
>
> 索引中的类字符串可以转换成index的类型，并且得到自然切片
>
> ```python
> In [41]: dfl.loc['20130102':'20130104']
> Out[41]: 
>                    A         B         C         D
> 2013-01-02  0.357021 -0.674600 -1.776904 -0.968914
> 2013-01-03 -1.294524  0.413738  0.276662 -0.472035
> 2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061
> ```
>
> > 警告：从0.21.0版开始，如果用包含缺失标签的列表进行索引时，Pandas将显示`FutureWarning`。将来，这将会抛出`KeyError`。查看 [list-like Using loc with missing keys in a list is Deprecated](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-deprecate-loc-reindex-listlike)获得更多信息。

为了支持纯粹的基于标签的索引，Pandas提供了一组方法。这是一个严格的基于包含的协议。每个被使用的标签必须是在索引中，否则会抛出一个`KerError`错误。执行切片时，如果首尾边界在索引中，它们都包含在内。整型是合法的标签，但它们指的是标签而不是位置。

`.loc`属性是主要的访问方法。下面列出了合法的输入：

- 单独的标签，比如`5`或`a`（注意：`5`会被解释为index的标签，这种用法`不是`index 的整数位置）。
- 标签列表或数组`['a', 'b', 'c', 'd']`。
- 标签切片对象`'a':'f'`（注意：与通常的Python切片相反，在索引中使用时，包含开始和结束，查看[按标签索引](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-slicing-with-labels)）。
- 布尔数组。
- 可调用对象，查看[使用可调用对象进行选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-callable)。

```python
In [42]: s1 = pd.Series(np.random.randn(6),index=list('abcdef'))

In [43]: s1
Out[43]: 
a    1.431256
b    1.340309
c   -1.170299
d   -0.226169
e    0.410835
f    0.813850
dtype: float64

In [44]: s1.loc['c':]
Out[44]: 
c   -1.170299
d   -0.226169
e    0.410835
f    0.813850
dtype: float64

In [45]: s1.loc['b']
Out[45]: 1.3403088497993827
```

注意，也可以用于赋值操作。

```python
In [46]: s1.loc['c':] = 0

In [47]: s1
Out[47]: 
a    1.431256
b    1.340309
c    0.000000
d    0.000000
e    0.000000
f    0.000000
dtype: float64
```

操作DataFrame：

```python
In [48]: df1 = pd.DataFrame(np.random.randn(6,4),
   ....:                    index=list('abcdef'),
   ....:                    columns=list('ABCD'))
   ....: 

In [49]: df1
Out[49]: 
          A         B         C         D
a  0.132003 -0.827317 -0.076467 -1.187678
b  1.130127 -1.436737 -1.413681  1.607920
c  1.024180  0.569605  0.875906 -2.211372
d  0.974466 -2.006747 -0.410001 -0.078638
e  0.545952 -1.219217 -1.226825  0.769804
f -1.281247 -0.727707 -0.121306 -0.097883

In [50]: df1.loc[['a', 'b', 'd'], :]
Out[50]: 
          A         B         C         D
a  0.132003 -0.827317 -0.076467 -1.187678
b  1.130127 -1.436737 -1.413681  1.607920
d  0.974466 -2.006747 -0.410001 -0.078638
```

使用标签切片访问：

```python
In [51]: df1.loc['d':, 'A':'C']
Out[51]: 
          A         B         C
d  0.974466 -2.006747 -0.410001
e  0.545952 -1.219217 -1.226825
f -1.281247 -0.727707 -0.121306
```

使用标签获得一个横截面（等价于`df.xs('a')`）：

```python
In [53]: df1.loc['a'] > 0
Out[53]: 
A     True
B    False
C    False
D    False
Name: a, dtype: bool

In [54]: df1.loc[:, df1.loc['a'] > 0]
Out[54]: 
          A
a  0.132003
b  1.130127
c  1.024180
d  0.974466
e  0.545952
f -1.281247
```

显示地获取一个值（等价于已经弃用的df.get_value('a', 'A')）：

```python
# this is also equivalent to ``df1.at['a','A']``
In [55]: df1.loc['a', 'A']
Out[55]: 0.13200317033032932
```

##### 12.5.1 使用标签进行切片

使用`.loc`进行切片时，如果起始和结束标签都在索引中，将会返回这两个标签中间的元素（包含开始和结束）：

```python
In [56]: s = pd.Series(list('abcde'), index=[0,3,2,5,4])

In [57]: s.loc[3:5]
Out[57]: 
3    b
2    c
5    d
dtype: object
```

如果开始和结束标签中至少有一个缺失，但是索引是排序后的，并且可以和起始标签和结束标签进行比较，那么，切片操作还是会按照预想的进行，选择序号在开始和结束标签中间的标签：

```python
In [58]: s.sort_index()
Out[58]: 
0    a
2    c
3    b
4    e
5    d
dtype: object

In [59]: s.sort_index().loc[1:6]
Out[59]: 
2    c
3    b
4    e
5    d
dtype: object
```

不过，如果开始和结束标签中至少有一个缺失，但是索引未被排序，将会抛出异常（因为不这样做计算成本很高，而且，对于混合类型的索引会有歧义）。在上面的例子中，`s.loc[1:6]`将会抛出`KerError`。

#### 12.6 按位置选择

> 警告：设置操作返回一个副本还是引用，可能取决于上下文。这有时称为`chained assignment`，并且应该避免。查看[Returning a View versus Copy](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-view-versus-copy)获得更多信息。

为了支持纯粹的基于整型的索引，Pandas提供了一组方法。语义基本遵循Python和Numpy的切片操作。这是从0开始的索引。切片时，包含开始边界，排除上限。使用非整型，即使是合法的标签也会抛出`IndexError`。

`.iloc`属性是主要的访问方法。下面列出了合法的输入：

- 单独的标签，比如`5`。
- 整型列表或数组`[4,3,0]`。
- 整型切片对象`1:7`。
- 布尔数组。
- 可调用对象，查看[使用可调用对象进行选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-callable)。

```python
In [60]: s1 = pd.Series(np.random.randn(5), index=list(range(0,10,2)))

In [61]: s1
Out[61]: 
0    0.695775
2    0.341734
4    0.959726
6   -1.110336
8   -0.619976
dtype: float64

In [62]: s1.iloc[:3]
Out[62]: 
0    0.695775
2    0.341734
4    0.959726
dtype: float64

In [63]: s1.iloc[3]
Out[63]: -1.1103361028911669
```

同样可以用于赋值：

```python
In [64]: s1.iloc[:3] = 0

In [65]: s1
Out[65]: 
0    0.000000
2    0.000000
4    0.000000
6   -1.110336
8   -0.619976
dtype: float64
```

操作DataFrame：

```python
In [66]: df1 = pd.DataFrame(np.random.randn(6,4),
   ....:                    index=list(range(0,12,2)),
   ....:                    columns=list(range(0,8,2)))
   ....: 

In [67]: df1
Out[67]: 
           0         2         4         6
0   0.149748 -0.732339  0.687738  0.176444
2   0.403310 -0.154951  0.301624 -2.179861
4  -1.369849 -0.954208  1.462696 -1.743161
6  -0.826591 -0.345352  1.314232  0.690579
8   0.995761  2.396780  0.014871  3.357427
10 -0.317441 -1.236269  0.896171 -0.487602
```

按整型切片：

```python
In [68]: df1.iloc[:3]
Out[68]: 
          0         2         4         6
0  0.149748 -0.732339  0.687738  0.176444
2  0.403310 -0.154951  0.301624 -2.179861
4 -1.369849 -0.954208  1.462696 -1.743161

In [69]: df1.iloc[1:5, 2:4]
Out[69]: 
          4         6
2  0.301624 -2.179861
4  1.462696 -1.743161
6  1.314232  0.690579
8  0.014871  3.357427
```

通过整型列表：

```python
In [70]: df1.iloc[[1, 3, 5], [1, 3]]
Out[70]: 
           2         6
2  -0.154951 -2.179861
6  -0.345352  0.690579
10 -1.236269 -0.487602
```

```python
In [71]: df1.iloc[1:3, :]
Out[71]: 
          0         2         4         6
2  0.403310 -0.154951  0.301624 -2.179861
4 -1.369849 -0.954208  1.462696 -1.743161
```

```python
In [72]: df1.iloc[:, 1:3]
Out[72]: 
           2         4
0  -0.732339  0.687738
2  -0.154951  0.301624
4  -0.954208  1.462696
6  -0.345352  1.314232
8   2.396780  0.014871
10 -1.236269  0.896171
```

```python
# this is also equivalent to ``df1.iat[1,1]``
In [73]: df1.iloc[1, 1]
Out[73]: -0.15495077442490321
```

使用整型位置获取一个横截面（等价于`df.xs(1)）：

```python
In [74]: df1.iloc[1]
Out[74]: 
0    0.403310
2   -0.154951
4    0.301624
6   -2.179861
Name: 2, dtype: float64
```

想在Python和Numpy那样优雅地处理超出范围的切片索引：

```python
# these are allowed in python/numpy.
In [75]: x = list('abcdef')

In [76]: x
Out[76]: ['a', 'b', 'c', 'd', 'e', 'f']

In [77]: x[4:10]
Out[77]: ['e', 'f']

In [78]: x[8:10]
Out[78]: []

In [79]: s = pd.Series(x)

In [80]: s
Out[80]: 
0    a
1    b
2    c
3    d
4    e
5    f
dtype: object

In [81]: s.iloc[4:10]
Out[81]: 
4    e
5    f
dtype: object

In [82]: s.iloc[8:10]
Out[82]: Series([], dtype: object)
```

注意：使用超出范围的切片会返回空轴（例如，返回一个空的DataFrame）：

```python
In [83]: dfl = pd.DataFrame(np.random.randn(5,2), columns=list('AB'))

In [84]: dfl
Out[84]: 
          A         B
0 -0.082240 -2.182937
1  0.380396  0.084844
2  0.432390  1.519970
3 -0.493662  0.600178
4  0.274230  0.132885

In [85]: dfl.iloc[:, 2:3]
Out[85]: 
Empty DataFrame
Columns: []
Index: [0, 1, 2, 3, 4]

In [86]: dfl.iloc[:, 1:3]
Out[86]: 
          B
0 -2.182937
1  0.084844
2  1.519970
3  0.600178
4  0.132885

In [87]: dfl.iloc[4:6]
Out[87]: 
         A         B
4  0.27423  0.132885
```

超出范围的单个索引器将会抛出`IndexError`。所有元素都在范围外的索引器列表将会抛出`IndexError`：

```python
dfl.iloc[[4, 5, 6]]
IndexError: positional indexers are out-of-bounds

dfl.iloc[:, 4]
IndexError: single positional indexer is out-of-bounds
```

#### 12.7 使用可调用对象选择

0.18.1版本新特性。

`.loc`、`.iloc`和`[]`索引都可以接受一个可调用对象作为索引器。这个可调用对象必须是一个单参数（被操作的Series，DataFrame或Panel）函数并且返回一个可用于索引的合法输出：

```python
In [88]: df1 = pd.DataFrame(np.random.randn(6, 4),
   ....:                    index=list('abcdef'),
   ....:                    columns=list('ABCD'))
   ....: 

In [89]: df1
Out[89]: 
          A         B         C         D
a -0.023688  2.410179  1.450520  0.206053
b -0.251905 -2.213588  1.063327  1.266143
c  0.299368 -0.863838  0.408204 -1.048089
d -0.025747 -0.988387  0.094055  1.262731
e  1.289997  0.082423 -0.055758  0.536580
f -0.489682  0.369374 -0.034571 -2.484478

In [90]: df1.loc[lambda df: df.A > 0, :]
Out[90]: 
          A         B         C         D
c  0.299368 -0.863838  0.408204 -1.048089
e  1.289997  0.082423 -0.055758  0.536580

In [91]: df1.loc[:, lambda df: ['A', 'B']]
Out[91]: 
          A         B
a -0.023688  2.410179
b -0.251905 -2.213588
c  0.299368 -0.863838
d -0.025747 -0.988387
e  1.289997  0.082423
f -0.489682  0.369374

In [92]: df1.iloc[:, lambda df: [0, 1]]
Out[92]: 
          A         B
a -0.023688  2.410179
b -0.251905 -2.213588
c  0.299368 -0.863838
d -0.025747 -0.988387
e  1.289997  0.082423
f -0.489682  0.369374

In [93]: df1[lambda df: df.columns[0]]
Out[93]: 
a   -0.023688
b   -0.251905
c    0.299368
d   -0.025747
e    1.289997
f   -0.489682
Name: A, dtype: float64
```

可以使用可调用对象对Series进行索引：

```python
In [94]: df1.A.loc[lambda s: s > 0]
Out[94]: 
c    0.299368
e    1.289997
Name: A, dtype: float64
```

使用这些方法或索引器，你可以不使用临时变量连接数据选择操作：

```python
In [95]: bb = pd.read_csv('data/baseball.csv', index_col='id')

In [96]: (bb.groupby(['year', 'team']).sum()
   ....:    .loc[lambda df: df.r > 100])
   ....: 
Out[96]: 
           stint    g    ab    r    h  X2b  X3b  hr    rbi    sb   cs   bb     so   ibb   hbp    sh    sf  gidp
year team                                                                                                      
2007 CIN       6  379   745  101  203   35    2  36  125.0  10.0  1.0  105  127.0  14.0   1.0   1.0  15.0  18.0
     DET       5  301  1062  162  283   54    4  37  144.0  24.0  7.0   97  176.0   3.0  10.0   4.0   8.0  28.0
     HOU       4  311   926  109  218   47    6  14   77.0  10.0  4.0   60  212.0   3.0   9.0  16.0   6.0  17.0
     LAN      11  413  1021  153  293   61    3  36  154.0   7.0  5.0  114  141.0   8.0   9.0   3.0   8.0  29.0
     NYN      13  622  1854  240  509  101    3  61  243.0  22.0  4.0  174  310.0  24.0  23.0  18.0  15.0  48.0
     SFN       5  482  1305  198  337   67    6  40  171.0  26.0  7.0  235  188.0  51.0   8.0  16.0   6.0  41.0
     TEX       2  198   729  115  200   40    4  28  115.0  21.0  4.0   73  140.0   4.0   5.0   2.0   8.0  16.0
     TOR       4  459  1408  187  378   96    2  58  223.0   4.0  2.0  190  265.0  16.0  12.0   4.0  16.0  38.0
```

#### 12.8 IX索引器被弃用

> 注意：从0.20.0版开始，为了支持更严格的`.loc`和`.iloc`操作，`.ix`索引器被弃用了。

`.ix`在推断用户想做什么方面提供了许多奇妙功能。`.ix`可以按位置索引，也可以按照取决于索引类型的标签进行索引。多年来，这给用户带来了很多困惑。

推荐的索引方法是：

- `.loc`：按标签索引。
- `.iloc`：按位置索引。

```python
In [97]: dfd = pd.DataFrame({'A': [1, 2, 3],
   ....:                     'B': [4, 5, 6]},
   ....:                    index=list('abc'))
   ....:

In [98]: dfd
Out[98]:
   A  B
a  1  4
b  2  5
c  3  6
```

按照之前的做法，如果你想得到A列的第0和第2个元素：

```python
In [3]: dfd.ix[[0, 2], 'A']
Out[3]:
a    1
c    3
Name: A, dtype: int64
```

使用`.loc`。这里，我们将从索引中选择合适的索引器，然后使用标签进行索引：

```python
In [99]: dfd.loc[dfd.index[[0, 2]], 'A']
Out[99]:
a    1
c    3
Name: A, dtype: int64
```

这个问题也可以使用`.iloc`，先显式地获取索引器上的位置，然后再使用位置进行索引：

```python
In [100]: dfd.iloc[[0, 2], dfd.columns.get_loc('A')]
Out[100]:
a    1
c    3
Name: A, dtype: int64
```

获取多个索引器，可以使用`.get_indexer`：

```python
In [101]: dfd.iloc[[0, 2], dfd.columns.get_indexer(['A', 'B'])]
Out[101]:
   A  B
a  1  4
c  3  6
```



#### 12.9 使用包含缺失标签的列表进行索引被弃用

> 注意：从0.21.0版开始，为了支持`reindex`操作，使用包含缺失标签的列表进行`.loc`或`[]`操作被弃用了。

在之前的版本中，使用`.loc[list-of-labels]`时，只要列表中有一个标签能够查到数据就能正常执行（否则会抛出KeyError错误）。这种使用方式被弃用了，推荐用法是使用`.reindex()`。

例如：

```python
In [102]: s = pd.Series([1, 2, 3])

In [103]: s
Out[103]:
0    1
1    2
2    3
dtype: int64
```

所有的key都能查到数据的使用方式没有修改：

```python
In [104]: s.loc[[1, 2]]
Out[104]:
1    2
2    3
dtype: int64
```

之前的处理方式：

```python
In [4]: s.loc[[1, 2, 3]]
Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64
```

现在的处理方式：

```python
In [4]: s.loc[[1, 2, 3]]
Passing list-likes to .loc with any non-matching elements will raise
KeyError in the future, you can use .reindex() as an alternative.

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike

Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64
```

##### 12.9.1 重建索引

实现选择可能找不到的元素的惯用方法是使用`.reindex()`。查看[reindexing](http://pandas.pydata.org/pandas-docs/version/0.23/basics.html#basics-reindexing)章节获取更多信息。

```python
In [105]: s.reindex([1, 2, 3])
Out[105]:
1    2.0
2    3.0
3    NaN
dtype: float64
```

可选地，如果你只想选择合法的key，下面的方法是常用而有效的，它能保留选择项的数据类型。

```python
In [106]: labels = [1, 2, 3]

In [107]: s.loc[s.index.intersection(labels)]
Out[107]:
1    2
2    3
dtype: int64
```

如果索引中有重复值，将会抛出异常。

```python
In [108]: s = pd.Series(np.arange(4), index=['a', 'a', 'b', 'c'])

In [109]: labels = ['c', 'd']
```

```python
In [17]: s.reindex(labels)
ValueError: cannot reindex from a duplicate axis
```

通常，你可以将所需的标签与当前轴交叉，然后重建索引。

```python
In [110]: s.loc[s.index.intersection(labels)].reindex(labels)
Out[110]:
c    3.0
d    NaN
dtype: float64
```

不过 ，如果索引中有重复值，同样会抛出异常。

```python
In [41]: labels = ['a', 'd']

In [42]: s.loc[s.index.intersection(labels)].reindex(labels)
ValueError: cannot reindex from a duplicate axis
```

#### 12.10 选择随机样本

[`sample()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.sample.html#pandas.DataFrame.sample)方法从Series、DataFrame或Panel中随机选择一定的行或列。默认地，这个方法随机选择行，同时接受一个数字来指定返回行还是列，或行的一部分。

```python
In [111]: s = pd.Series([0,1,2,3,4,5])

# When no arguments are passed, returns 1 row.
In [112]: s.sample()
Out[112]:
4    4
dtype: int64

# One may specify either a number of rows:
In [113]: s.sample(n=3)
Out[113]:
0    0
4    4
1    1
dtype: int64

# Or a fraction of the rows:
In [114]: s.sample(frac=0.5)
Out[114]:
5    5
3    3
1    1
dtype: int64
```

默认地，使用`sample`时，每一行最多返回一次，但是也可以通过`replace`选项来决定抽样时是否替换。

```python
In [115]: s = pd.Series([0,1,2,3,4,5])

 # Without replacement (default):
In [116]: s.sample(n=6, replace=False)
Out[116]:
0    0
1    1
5    5
3    3
2    2
4    4
dtype: int64

 # With replacement:
In [117]: s.sample(n=6, replace=True)
Out[117]:
0    0
4    4
3    3
2    2
4    4
4    4
dtype: int64
```

默认地，每一行都有可能被选择。如果你想让每一行被选择的概率不同，可以为sample函数传入一个weights参数。这个weights参数可以是一个列表，Numpy数组或一个Series，但它的长度必须和想要抽样的对象的长度一样。缺失值的权重会被处理成0，无穷大不允许使用。如果权重的和不等于1，将会重新计算权重，计算方法是每一个的权重除以权重之和。例如：

```python
In [118]: s = pd.Series([0,1,2,3,4,5])

In [119]: example_weights = [0, 0, 0.2, 0.2, 0.2, 0.4]

In [120]: s.sample(n=3, weights=example_weights)
Out[120]:
5    5
4    4
3    3
dtype: int64

# Weights will be re-normalized automatically
In [121]: example_weights2 = [0.5, 0, 0, 0, 0, 0]

In [122]: s.sample(n=1, weights=example_weights2)
Out[122]:
0    0
dtype: int64
```

对DataFrame抽样时，可以指定某一列（只要指定该列的列名字符串）作为抽样权重。

```python
In [123]: df2 = pd.DataFrame({'col1':[9,8,7,6], 'weight_column':[0.5, 0.4, 0.1, 0]})

In [124]: df2.sample(n = 3, weights = 'weight_column')
Out[124]:
   col1  weight_column
1     8            0.4
0     9            0.5
2     7            0.1
```

传入`axis`参数可以对列进行抽样

```python
In [125]: df3 = pd.DataFrame({'col1':[1,2,3], 'col2':[2,3,4]})

In [126]: df3.sample(n=1, axis=1)
Out[126]:
   col1
0     1
1     2
2     3
```

最后，可以传入`random_state`参数设置随机种子，该参数接受一个整数（作为种子）或一个Numpy RandomState对象。

```python
In [127]: df4 = pd.DataFrame({'col1':[1,2,3], 'col2':[2,3,4]})

# With a given seed, the sample will always draw the same rows.
In [128]: df4.sample(n=2, random_state=2)
Out[128]:
   col1  col2
2     3     4
1     2     3

In [129]: df4.sample(n=2, random_state=2)
Out[129]:
   col1  col2
2     3     4
1     2     3
```

#### 12.11 设置与扩大

`.loc`或`[]`操作可以在设置某个轴上不存在的key时执行扩大操作。

对于Series，这是一种有效的追加操作。

```python
In [130]: se = pd.Series([1,2,3])

In [131]: se
Out[131]:
0    1
1    2
2    3
dtype: int64

In [132]: se[5] = 5.

In [133]: se
Out[133]:
0    1.0
1    2.0
2    3.0
5    5.0
dtype: float64
```

DataFrame可以通过`.loc`在任意轴上执行扩大操作：

```python
In [134]: dfi = pd.DataFrame(np.arange(6).reshape(3,2),
   .....:                 columns=['A','B'])
   .....:

In [135]: dfi
Out[135]:
   A  B
0  0  1
1  2  3
2  4  5

In [136]: dfi.loc[:,'C'] = dfi.loc[:,'A']

In [137]: dfi
Out[137]:
   A  B  C
0  0  1  0
1  2  3  2
2  4  5  4
```

这和`append`操作类似：

```python
In [138]: dfi.loc[3] = 5

In [139]: dfi
Out[139]:
   A  B  C
0  0  1  0
1  2  3  2
2  4  5  4
3  5  5  5
```

#### 12.12 快速获取标量数据

由于通过`[]`来索引必须处理大部分情况（单标签访问，切片，布尔索引等等），它会有一些开销来确定你想要的内容。如果你只想获取一个标量数据，最快的方式是使用`.at`和`.iat`方法，这两个方法在所有的数据结构上都实现了。

与`.loc`类似，`.at`提供了基于标签的标量查找，`.iat`提供了基于整数的查找，类似于`.iloc`：

```python
In [140]: s.iat[5]
Out[140]: 5

In [141]: df.at[dates[5], 'A']
Out[141]: -0.67368970808837059

In [142]: df.iat[3, 0]
Out[142]: 0.72155516224436689
```

也可以使用同样的索引器设置数值

```
In [143]: df.at[dates[5], 'E'] = 7

In [144]: df.iat[3, 0] = 7
```

如果索引器缺失，`.at`将会按照上面的方式放大对象

```python
In [145]: df.at[dates[-1]+1, 0] = 7

In [146]: df
Out[146]:
                   A         B         C         D    E    0
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632  NaN  NaN
2000-01-02  1.212112 -0.173215  0.119209 -1.044236  NaN  NaN
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804  NaN  NaN
2000-01-04  7.000000 -0.706771 -1.039575  0.271860  NaN  NaN
2000-01-05 -0.424972  0.567020  0.276232 -1.087401  NaN  NaN
2000-01-06 -0.673690  0.113648 -1.478427  0.524988  7.0  NaN
2000-01-07  0.404705  0.577046 -1.715002 -1.039268  NaN  NaN
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885  NaN  NaN
2000-01-09       NaN       NaN       NaN       NaN  NaN  7.0
```

#### 12.13 布尔索引

另一个常用的操作是按照布尔向量选择数据。操作符是`|`（代表or），`&`（代表and）和`~`（代表not）。这些操作必须用括号分组，因为Python会计算一个表达式，比如`df.A > 2 & df.B < 3` as `df.A > (2 & df.B) < 3`的期望计算顺序是`(df.A > 2) & (df.B < 3)`。

使用布尔向量来索引一个Series时，和在Numpy数组中的工作方式一样：

```python
In [147]: s = pd.Series(range(-3, 4))

In [148]: s
Out[148]:
0   -3
1   -2
2   -1
3    0
4    1
5    2
6    3
dtype: int64

In [149]: s[s > 0]
Out[149]:
4    1
5    2
6    3
dtype: int64

In [150]: s[(s < -1) | (s > 0.5)]
Out[150]:
0   -3
1   -2
4    1
5    2
6    3
dtype: int64

In [151]: s[~(s < 0)]
Out[151]:
3    0
4    1
5    2
6    3
dtype: int64
```

您可以使用与DataFrame索引长度相同的布尔向量从DataFrame中选择行（例如，从DataFrame的一列派生的内容）:

```python
In [152]: df[df['A'] > 0]
Out[152]:
                   A         B         C         D   E   0
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632 NaN NaN
2000-01-02  1.212112 -0.173215  0.119209 -1.044236 NaN NaN
2000-01-04  7.000000 -0.706771 -1.039575  0.271860 NaN NaN
2000-01-07  0.404705  0.577046 -1.715002 -1.039268 NaN NaN
```

Series的列表推导和map方法也可以用来生成更复杂的条件：

```python
In [153]: df2 = pd.DataFrame({'a' : ['one', 'one', 'two', 'three', 'two', 'one', 'six'],
   .....:                     'b' : ['x', 'y', 'y', 'x', 'y', 'x', 'x'],
   .....:                     'c' : np.random.randn(7)})
   .....:

# only want 'two' or 'three'
In [154]: criterion = df2['a'].map(lambda x: x.startswith('t'))

In [155]: df2[criterion]
Out[155]:
       a  b         c
2    two  y  0.041290
3  three  x  0.361719
4    two  y -0.238075

# equivalent but slower
In [156]: df2[[x.startswith('t') for x in df2['a']]]
Out[156]:
       a  b         c
2    two  y  0.041290
3  three  x  0.361719
4    two  y -0.238075

# Multiple criteria
In [157]: df2[criterion & (df2['b'] == 'x')]
Out[157]:
       a  b         c
3  three  x  0.361719
```

使用选择方法[Selection by Label](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-label), [Selection by Position](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-integer), and [Advanced Indexing](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced)，你可以使用布尔向量和其他索引表达式结合对多个轴进行索引。

```python
In [158]: df2.loc[criterion & (df2['b'] == 'x'),'b':'c']
Out[158]:
   b         c
3  x  0.361719
```

#### 12.14 使用isin进行索引

考虑Series的`isin()`方法，该方法返回一个布尔向量，Series的元素存在于传入的列表中，则布尔向量的对应位置为True。这允许你选择一列或多列具有你需要的值的行：

```python
In [159]: s = pd.Series(np.arange(5), index=np.arange(5)[::-1], dtype='int64')

In [160]: s
Out[160]:
4    0
3    1
2    2
1    3
0    4
dtype: int64

In [161]: s.isin([2, 4, 6])
Out[161]:
4    False
3    False
2     True
1    False
0     True
dtype: bool

In [162]: s[s.isin([2, 4, 6])]
Out[162]:
2    2
0    4
dtype: int64
```

Index对象可以使用相同的方法，当您不知道哪些搜索标签实际存在时，它们非常有用：

```python
In [163]: s[s.index.isin([2, 4, 6])]
Out[163]:
4    0
2    2
dtype: int64

# compare it to the following
In [164]: s.reindex([2, 4, 6])
Out[164]:
2    2.0
4    0.0
6    NaN
dtype: float64
```

除此之外，MultiIndex允许选择在成员资格检查中使用的单独等级：

```python
In [165]: s_mi = pd.Series(np.arange(6),
   .....:                  index=pd.MultiIndex.from_product([[0, 1], ['a', 'b', 'c']]))
   .....:

In [166]: s_mi
Out[166]:
0  a    0
   b    1
   c    2
1  a    3
   b    4
   c    5
dtype: int64

In [167]: s_mi.iloc[s_mi.index.isin([(1, 'a'), (2, 'b'), (0, 'c')])]
Out[167]:
0  c    2
1  a    3
dtype: int64

In [168]: s_mi.iloc[s_mi.index.isin(['a', 'c', 'e'], level=1)]
Out[168]:
0  a    0
   c    2
1  a    3
   c    5
dtype: int64
```

DataFrame也有[`isin()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.isin.html#pandas.DataFrame.isin)方法。当调用`isin`时，传入一个数值集合，可以是数组也可以是字典。如果数据是一个数组，`isin`放回一个值为布尔值的和原始DataFrame形状一样的DataFrame，原始DataFrame某个位置的值存在于传入的数值序列中，返回的DataFrame中该位置的值为True。

```python
In [169]: df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['a', 'b', 'f', 'n'],
   .....:                    'ids2': ['a', 'n', 'c', 'n']})
   .....:

In [170]: values = ['a', 'b', 1, 3]

In [171]: df.isin(values)
Out[171]:
    vals    ids   ids2
0   True   True   True
1  False   True  False
2   True  False  False
3  False  False  False
```

许多时候，你想要将某些值与特定的列对应。只需要传入一个字典，字典的key是列名，值为你想要检查的元素列表。

```python
In [172]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}

In [173]: df.isin(values)
Out[173]:
    vals    ids   ids2
0   True   True  False
1  False   True  False
2   True  False  False
3  False  False  False
```

将DataFrame的`isin`方法与`any()`和`all()`方法结合使用，可以快速选择满足给定条件的数据子集。比如，选择每列符合其自身条件的行：

```python
In [174]: values = {'ids': ['a', 'b'], 'ids2': ['a', 'c'], 'vals': [1, 3]}

In [175]: row_mask = df.isin(values).all(1)

In [176]: df[row_mask]
Out[176]:
   vals ids ids2
0     1   a    a
```

#### 12.15 [`where()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.where.html#pandas.DataFrame.where)方法和[`mask()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.mask.html#pandas.DataFrame.mask)方法

使用布尔向量从Series中选择数据返回数据的一个子集。要确保输出与原始数据具有相同的形状，可以使用Series和DataFrame的`where`方法。

只返回选择的行：

```python
In [177]: s[s > 0]
Out[177]:
3    1
2    2
1    3
0    4
dtype: int64
```

返回与原始数据形状相同的Series：

```python
In [178]: s.where(s > 0)
Out[178]:
4    NaN
3    1.0
2    2.0
1    3.0
0    4.0
dtype: float64
```

现在，使用布尔条件从DataFrame中选择数据也可以保留输入数据的形状。这种情况下，实现方式是在引擎下使用`where`。下面的代码等价于`df.where(df<0)`：

```python
In [179]: df[df < 0]
Out[179]:
                   A         B         C         D
2000-01-01 -2.104139 -1.309525       NaN       NaN
2000-01-02 -0.352480       NaN -1.192319       NaN
2000-01-03 -0.864883       NaN -0.227870       NaN
2000-01-04       NaN -1.222082       NaN -1.233203
2000-01-05       NaN -0.605656 -1.169184       NaN
2000-01-06       NaN -0.948458       NaN -0.684718
2000-01-07 -2.670153 -0.114722       NaN -0.048048
2000-01-08       NaN       NaN -0.048788 -0.808838
```

另外，`where`有一个可选的`other`参数，来设置返回的副本中值为False的位置的替换方法。

```python
In [180]: df.where(df < 0, -df)
Out[180]:
                   A         B         C         D
2000-01-01 -2.104139 -1.309525 -0.485855 -0.245166
2000-01-02 -0.352480 -0.390389 -1.192319 -1.655824
2000-01-03 -0.864883 -0.299674 -0.227870 -0.281059
2000-01-04 -0.846958 -1.222082 -0.600705 -1.233203
2000-01-05 -0.669692 -0.605656 -1.169184 -0.342416
2000-01-06 -0.868584 -0.948458 -2.297780 -0.684718
2000-01-07 -2.670153 -0.114722 -0.168904 -0.048048
2000-01-08 -0.801196 -1.392071 -0.048788 -0.808838
```

您可能希望根据某些布尔条件设置值。 这可以直观地完成，如下所示：

```python
In [181]: s2 = s.copy()

In [182]: s2[s2 < 0] = 0

In [183]: s2
Out[183]:
4    0
3    1
2    2
1    3
0    4
dtype: int64

In [184]: df2 = df.copy()

In [185]: df2[df2 < 0] = 0

In [186]: df2
Out[186]:
                   A         B         C         D
2000-01-01  0.000000  0.000000  0.485855  0.245166
2000-01-02  0.000000  0.390389  0.000000  1.655824
2000-01-03  0.000000  0.299674  0.000000  0.281059
2000-01-04  0.846958  0.000000  0.600705  0.000000
2000-01-05  0.669692  0.000000  0.000000  0.342416
2000-01-06  0.868584  0.000000  2.297780  0.000000
2000-01-07  0.000000  0.000000  0.168904  0.000000
2000-01-08  0.801196  1.392071  0.000000  0.000000
```

默认情况下，`where`方法返回修改后的数据副本。有一个可选参数`inplace`，可以在不创建副本的情况下修改原始数据：

```python
In [187]: df_orig = df.copy()

In [188]: df_orig.where(df > 0, -df, inplace=True);

In [189]: df_orig
Out[189]:
                   A         B         C         D
2000-01-01  2.104139  1.309525  0.485855  0.245166
2000-01-02  0.352480  0.390389  1.192319  1.655824
2000-01-03  0.864883  0.299674  0.227870  0.281059
2000-01-04  0.846958  1.222082  0.600705  1.233203
2000-01-05  0.669692  0.605656  1.169184  0.342416
2000-01-06  0.868584  0.948458  2.297780  0.684718
2000-01-07  2.670153  0.114722  0.168904  0.048048
2000-01-08  0.801196  1.392071  0.048788  0.808838
```

> 注意：[`DataFrame.where()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.where.html#pandas.DataFrame.where)的签名与[`numpy.where()`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where)不同。 大概地，`df1.where(m，df2)`等价于`np.where(m，df1，df2)`。
>
> ```python
> In [190]: df.where(df < 0, -df) == np.where(df < 0, df, -df)
> Out[190]:
>                A     B     C     D
> 2000-01-01  True  True  True  True
> 2000-01-02  True  True  True  True
> 2000-01-03  True  True  True  True
> 2000-01-04  True  True  True  True
> 2000-01-05  True  True  True  True
> 2000-01-06  True  True  True  True
> 2000-01-07  True  True  True  True
> 2000-01-08  True  True  True  True
> ```

#### 12.15.1 对齐

另外，`where`对齐了输入布尔条件（数组或DataFrame），因此，使用部分选择进行设置成为可能。这类似于使用`.loc`进行部分设置（但是在内容上而不是在轴标签上）

```python
In [191]: df2 = df.copy()

In [192]: df2[ df2[1:4] > 0] = 3

In [193]: df2
Out[193]:
                   A         B         C         D
2000-01-01 -2.104139 -1.309525  0.485855  0.245166
2000-01-02 -0.352480  3.000000 -1.192319  3.000000
2000-01-03 -0.864883  3.000000 -0.227870  3.000000
2000-01-04  3.000000 -1.222082  3.000000 -1.233203
2000-01-05  0.669692 -0.605656 -1.169184  0.342416
2000-01-06  0.868584 -0.948458  2.297780 -0.684718
2000-01-07 -2.670153 -0.114722  0.168904 -0.048048
2000-01-08  0.801196  1.392071 -0.048788 -0.808838
```

`where`也接受`axis`和`level`参数来对齐输入：

```python
In [194]: df2 = df.copy()

In [195]: df2.where(df2>0,df2['A'],axis='index')
Out[195]:
                   A         B         C         D
2000-01-01 -2.104139 -2.104139  0.485855  0.245166
2000-01-02 -0.352480  0.390389 -0.352480  1.655824
2000-01-03 -0.864883  0.299674 -0.864883  0.281059
2000-01-04  0.846958  0.846958  0.600705  0.846958
2000-01-05  0.669692  0.669692  0.669692  0.342416
2000-01-06  0.868584  0.868584  2.297780  0.868584
2000-01-07 -2.670153 -2.670153  0.168904 -2.670153
2000-01-08  0.801196  1.392071  0.801196  0.801196
```

这等价于（但更快）下面的代码

```python
In [196]: df2 = df.copy()

In [197]: df.apply(lambda x, y: x.where(x>0,y), y=df['A'])
Out[197]:
                   A         B         C         D
2000-01-01 -2.104139 -2.104139  0.485855  0.245166
2000-01-02 -0.352480  0.390389 -0.352480  1.655824
2000-01-03 -0.864883  0.299674 -0.864883  0.281059
2000-01-04  0.846958  0.846958  0.600705  0.846958
2000-01-05  0.669692  0.669692  0.669692  0.342416
2000-01-06  0.868584  0.868584  2.297780  0.868584
2000-01-07 -2.670153 -2.670153  0.168904 -2.670153
2000-01-08  0.801196  1.392071  0.801196  0.801196
```

0.18.1版本新特性

`where`接受一个可调用对象作为条件和`other`参数。该函数必须只有一个参数（被调用的Series或DataFrame），必须返回合法的能够作为条件和`other`参数的输出：

```python
In [198]: df3 = pd.DataFrame({'A': [1, 2, 3],
   .....:                     'B': [4, 5, 6],
   .....:                     'C': [7, 8, 9]})
   .....:

In [199]: df3.where(lambda x: x > 4, lambda x: x + 10)
Out[199]:
    A   B  C
0  11  14  7
1  12   5  8
2  13   6  9
```

#### 12.15.2  Mask

[`mask()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.mask.html#pandas.DataFrame.mask)是`where`方法的反布尔运算

```python
In [200]: s.mask(s >= 0)
Out[200]:
4   NaN
3   NaN
2   NaN
1   NaN
0   NaN
dtype: float64

In [201]: df.mask(df >= 0)
Out[201]:
                   A         B         C         D
2000-01-01 -2.104139 -1.309525       NaN       NaN
2000-01-02 -0.352480       NaN -1.192319       NaN
2000-01-03 -0.864883       NaN -0.227870       NaN
2000-01-04       NaN -1.222082       NaN -1.233203
2000-01-05       NaN -0.605656 -1.169184       NaN
2000-01-06       NaN -0.948458       NaN -0.684718
2000-01-07 -2.670153 -0.114722       NaN -0.048048
2000-01-08       NaN       NaN -0.048788 -0.808838
```

#### 12.16 [`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query)方法

[`DataFrame`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.html#pandas.DataFrame)对象有一个 [`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query) 方法，允许使用表达式选择数据。

你可以获取数据框中b列的值介于a列值和c列值之间的数据。例如：

```python
In [202]: n = 10

In [203]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [204]: df
Out[204]:
          a         b         c
0  0.438921  0.118680  0.863670
1  0.138138  0.577363  0.686602
2  0.595307  0.564592  0.520630
3  0.913052  0.926075  0.616184
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
6  0.792342  0.216974  0.564056
7  0.397890  0.454131  0.915716
8  0.074315  0.437913  0.019794
9  0.559209  0.502065  0.026437

# pure python
In [205]: df[(df.a < df.b) & (df.b < df.c)]
Out[205]:
          a         b         c
1  0.138138  0.577363  0.686602
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
7  0.397890  0.454131  0.915716

# query
In [206]: df.query('(a < b) & (b < c)')
Out[206]:
          a         b         c
1  0.138138  0.577363  0.686602
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
7  0.397890  0.454131  0.915716
```

如果没有名称为a的列，则执行相同的操作但转而使用一个命名索引。

```python
In [207]: df = pd.DataFrame(np.random.randint(n / 2, size=(n, 2)), columns=list('bc'))

In [208]: df.index.name = 'a'

In [209]: df
Out[209]:
   b  c
a      
0  0  4
1  0  1
2  3  4
3  4  3
4  1  4
5  0  3
6  0  1
7  3  4
8  2  3
9  1  1

In [210]: df.query('a < b and b < c')
Out[210]:
   b  c
a      
2  3  4
```

如果您不希望或不能命名索引，则可以在查询表达式中使用`index`：

```python
In [211]: df = pd.DataFrame(np.random.randint(n, size=(n, 2)), columns=list('bc'))

In [212]: df
Out[212]:
   b  c
0  3  1
1  3  0
2  5  6
3  5  2
4  7  4
5  0  1
6  2  5
7  0  1
8  6  0
9  7  9

In [213]: df.query('index < b < c')
Out[213]:
   b  c
2  5  6
```

> 注意：如果索引的名称与列名称重叠，则列名称优先。 例如：
>
> ```python
> In [214]: df = pd.DataFrame({'a': np.random.randint(5, size=5)})
>
> In [215]: df.index.name = 'a'
>
> In [216]: df.query('a > 2') # uses the column 'a', not the index
> Out[216]:
>    a
> a   
> 1  3
> 3  3
> ```
>
> 您仍然可以使用特殊标识符`index`在查询表达式中使用索引：
>
> ```python
> In [217]: df.query('index > 2')
> Out[217]:
>    a
> a   
> 3  3
> 4  2
> ```
>
> 如果由于某种原因你有一个名为index的列，那么你也可以将索引称为ilevel_0，但此时你应该考虑将列重命名为不那么模糊的名称。

##### 12.16.1  [`MultiIndex`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.MultiIndex.html#pandas.MultiIndex) [`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query)语法

您还可以将DataFrame的级别与[MultiIndex](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.MultiIndex.html#pandas.MultiIndex)一起使用，就像它们是数据框中的列一样：

```python
In [218]: n = 10

In [219]: colors = np.random.choice(['red', 'green'], size=n)

In [220]: foods = np.random.choice(['eggs', 'ham'], size=n)

In [221]: colors
Out[221]:
array(['red', 'red', 'red', 'green', 'green', 'green', 'green', 'green',
       'green', 'green'],
      dtype='<U5')

In [222]: foods
Out[222]:
array(['ham', 'ham', 'eggs', 'eggs', 'eggs', 'ham', 'ham', 'eggs', 'eggs',
       'eggs'],
      dtype='<U4')

In [223]: index = pd.MultiIndex.from_arrays([colors, foods], names=['color', 'food'])

In [224]: df = pd.DataFrame(np.random.randn(n, 2), index=index)

In [225]: df
Out[225]:
                   0         1
color food                    
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
green eggs -0.748199  1.318931
      eggs -2.029766  0.792652
      ham   0.461007 -0.542749
      ham  -0.305384 -0.479195
      eggs  0.095031 -0.270099
      eggs -0.707140 -0.773882
      eggs  0.229453  0.304418

In [226]: df.query('color == "red"')
Out[226]:
                   0         1
color food                    
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
```

如果MultiIndex没有命名，则可以使用特殊名称指代它们：

```python
In [227]: df.index.names = [None, None]

In [228]: df
Out[228]:
                   0         1
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
green eggs -0.748199  1.318931
      eggs -2.029766  0.792652
      ham   0.461007 -0.542749
      ham  -0.305384 -0.479195
      eggs  0.095031 -0.270099
      eggs -0.707140 -0.773882
      eggs  0.229453  0.304418

In [229]: df.query('ilevel_0 == "red"')
Out[229]:
                 0         1
red ham   0.194889 -0.381994
    ham   0.318587  2.089075
    eggs -0.728293 -0.090255
```

约定是，ilevel_0意思是`index level 0`，指代index的第0级。

##### 12.16.2 [`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query)用例

[`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query)的一个用例是，当你拥有一组DataFrame对象时，这些对象具有共同的列名（或索引级别或名称）的子集。你可以将相同的查询传递给两个数据框，无需指定你想查询的数据框。

```python
In [230]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [231]: df
Out[231]:
          a         b         c
0  0.224283  0.736107  0.139168
1  0.302827  0.657803  0.713897
2  0.611185  0.136624  0.984960
3  0.195246  0.123436  0.627712
4  0.618673  0.371660  0.047902
5  0.480088  0.062993  0.185760
6  0.568018  0.483467  0.445289
7  0.309040  0.274580  0.587101
8  0.258993  0.477769  0.370255
9  0.550459  0.840870  0.304611

In [232]: df2 = pd.DataFrame(np.random.rand(n + 2, 3), columns=df.columns)

In [233]: df2
Out[233]:
           a         b         c
0   0.357579  0.229800  0.596001
1   0.309059  0.957923  0.965663
2   0.123102  0.336914  0.318616
3   0.526506  0.323321  0.860813
4   0.518736  0.486514  0.384724
5   0.190804  0.505723  0.614533
6   0.891939  0.623977  0.676639
7   0.480559  0.378528  0.460858
8   0.420223  0.136404  0.141295
9   0.732206  0.419540  0.604675
10  0.604466  0.848974  0.896165
11  0.589168  0.920046  0.732716

In [234]: expr = '0.0 <= a <= c <= 0.5'

In [235]: map(lambda frame: frame.query(expr), [df, df2])
Out[235]: <map at 0x1c2fbb2780>
```

##### 12.16.3 [`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query)Python与Pandas语法比较

完全类似Numpy语法

```python
In [236]: df = pd.DataFrame(np.random.randint(n, size=(n, 3)), columns=list('abc'))

In [237]: df
Out[237]:
   a  b  c
0  7  8  9
1  1  0  7
2  2  7  2
3  6  2  2
4  2  6  3
5  3  8  2
6  1  7  2
7  5  1  5
8  9  8  0
9  1  5  0

In [238]: df.query('(a < b) & (b < c)')
Out[238]:
   a  b  c
0  7  8  9

In [239]: df[(df.a < df.b) & (df.b < df.c)]
Out[239]:
   a  b  c
0  7  8  9
```

去掉括号更美观（通过绑定使比较运算符绑定比＆和|更严格）

```python
In [240]: df.query('a < b & b < c')
Out[240]:
   a  b  c
0  7  8  9
```

使用英文替代符号

```python
In [241]: df.query('a < b and b < c')
Out[241]:
   a  b  c
0  7  8  9
```

非常接近你在纸上写的方式：

```python
In [242]: df.query('a < b < c')
Out[242]:
   a  b  c
0  7  8  9
```

##### 12.16.4 `in`和`not in`操作

[`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query) 还支持Python的`in`和`not in`比较操作的特殊使用，为调用Series和DataFrame的`isin`方法提供了简洁的语法。

```python
# get all rows where columns "a" and "b" have overlapping values
In [243]: df = pd.DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),
   .....:                    'c': np.random.randint(5, size=12),
   .....:                    'd': np.random.randint(9, size=12)})
   .....:

In [244]: df
Out[244]:
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

In [245]: df.query('a in b')
Out[245]:
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
3  b  a  2  1
4  c  b  3  6
5  c  b  0  2

# How you'd do it in pure Python
In [246]: df[df.a.isin(df.b)]
Out[246]:
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
3  b  a  2  1
4  c  b  3  6
5  c  b  0  2

In [247]: df.query('a not in b')
Out[247]:
    a  b  c  d
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

# pure Python
In [248]: df[~df.a.isin(df.b)]
Out[248]:
    a  b  c  d
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2
```

您可以把他与其他表达式结合使用，以获得非常简洁的查询：

```python
# rows where cols a and b have overlapping values and col c's values are less than col d's
In [249]: df.query('a in b and c < d')
Out[249]:
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
4  c  b  3  6
5  c  b  0  2

# pure Python
In [250]: df[df.b.isin(df.a) & (df.c < df.d)]
Out[250]:
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
4   c  b  3  6
5   c  b  0  2
10  f  c  0  6
11  f  c  1  2
```

> 注意：`in`和`not in`在Python中计算，因为`numexpr`没有对应的操作。不过，只有in/not in表达式自己会在普通Python中计算。例如，在表达式
>
> ```python
> df.query('a in b + c + d')
> ```
>
> 中，`(b + c + d)`会被`numexpr`计算，然后`in`操作在普通Python中计算。通常，任何可以用`numexpr`计算的操作都可以。

##### 12.16.5 列表对象的==操作的特殊使用

使用`==`或`!=`将值列表与列进行比较的方式类似于`in`或`not in`

```python
In [251]: df.query('b == ["a", "b", "c"]')
Out[251]:
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

# pure Python
In [252]: df[df.b.isin(["a", "b", "c"])]
Out[252]:
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

In [253]: df.query('c == [1, 2]')
Out[253]:
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2

In [254]: df.query('c != [1, 2]')
Out[254]:
    a  b  c  d
1   a  a  4  7
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
8   e  c  4  3
10  f  c  0  6

# using in/not in
In [255]: df.query('[1, 2] in c')
Out[255]:
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2

In [256]: df.query('[1, 2] not in c')
Out[256]:
    a  b  c  d
1   a  a  4  7
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
8   e  c  4  3
10  f  c  0  6

# pure Python
In [257]: df[df.c.isin([1, 2])]
Out[257]:
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2
```

##### 12.16.6 布尔操作

你可以使用`not`或`~`操作对布尔表达式取反：

```python
In [258]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [259]: df['bools'] = np.random.rand(len(df)) > 0.5

In [260]: df.query('~bools')
Out[260]:
          a         b         c  bools
2  0.697753  0.212799  0.329209  False
7  0.275396  0.691034  0.826619  False
8  0.190649  0.558748  0.262467  False

In [261]: df.query('not bools')
Out[261]:
          a         b         c  bools
2  0.697753  0.212799  0.329209  False
7  0.275396  0.691034  0.826619  False
8  0.190649  0.558748  0.262467  False

In [262]: df.query('not bools') == df[~df.bools]
Out[262]:
      a     b     c  bools
2  True  True  True   True
7  True  True  True   True
8  True  True  True   True
```

当然，表达式也可以是任意复杂的：

```python
# short query syntax
In [263]: shorter = df.query('a < b < c and (not bools) or bools > 2')

# equivalent in pure Python
In [264]: longer = df[(df.a < df.b) & (df.b < df.c) & (~df.bools) | (df.bools > 2)]

In [265]: shorter
Out[265]:
          a         b         c  bools
7  0.275396  0.691034  0.826619  False

In [266]: longer
Out[266]:
          a         b         c  bools
7  0.275396  0.691034  0.826619  False

In [267]: shorter == longer
Out[267]:
      a     b     c  bools
7  True  True  True   True
```

##### 12.16.7 [`query()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.query.html#pandas.DataFrame.query)性能

对于大型数据框，使用`numexpr`的`DataFrame.query()`比Python略快

![_images/query-perf.png](http://pandas.pydata.org/pandas-docs/version/0.23/_images/query-perf.png)

> 注意：如果您的框架超过大约200,000行，您将只看到使用带有`DataFrame.query()`的`numexpr`引擎的性能优势
>
> ![_images/query-perf-small.png](http://pandas.pydata.org/pandas-docs/version/0.23/_images/query-perf-small.png)

这张图是使用一个包含3列的DataFrame创建的，每列包含使用`numpy.random.randn()`生成的浮点值。

#### 12.17 重复数据

如果你想识别和删除DataFrame中的重复数据，有两个方法可以使用：`duplicated`和`drop_duplicates`。每个方法都将用于标识重复行的列作为参数。

- `duplicated`：返回一个布尔向量，该向量的长度是行的数量，表示某一行是否重复。
- `drop_duplicates`：删除重复的行。

默认地，重复数据中的第一个观察行将会被认为是唯一的，但每个方法都有一个`keep`参数来指定要保留的目标。

- `keep='first'`:（默认），标记/删除重复值，除了第一个出现的行。
- `keep='last'`：标记/删除重复值，除了最后一个出现的行。
- `keep=False`：删除所有的重复行。

```python
In [268]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'two', 'two', 'three', 'four'],
   .....:                     'b': ['x', 'y', 'x', 'y', 'x', 'x', 'x'],
   .....:                     'c': np.random.randn(7)})
   .....:

In [269]: df2
Out[269]:
       a  b         c
0    one  x -1.067137
1    one  y  0.309500
2    two  x -0.211056
3    two  y -1.842023
4    two  x -0.390820
5  three  x -1.964475
6   four  x  1.298329

In [270]: df2.duplicated('a')
Out[270]:
0    False
1     True
2    False
3     True
4     True
5    False
6    False
dtype: bool

In [271]: df2.duplicated('a', keep='last')
Out[271]:
0     True
1    False
2     True
3     True
4    False
5    False
6    False
dtype: bool

In [272]: df2.duplicated('a', keep=False)
Out[272]:
0     True
1     True
2     True
3     True
4     True
5    False
6    False
dtype: bool

In [273]: df2.drop_duplicates('a')
Out[273]:
       a  b         c
0    one  x -1.067137
2    two  x -0.211056
5  three  x -1.964475
6   four  x  1.298329

In [274]: df2.drop_duplicates('a', keep='last')
Out[274]:
       a  b         c
1    one  y  0.309500
4    two  x -0.390820
5  three  x -1.964475
6   four  x  1.298329

In [275]: df2.drop_duplicates('a', keep=False)
Out[275]:
       a  b         c
5  three  x -1.964475
6   four  x  1.298329
```

另外，你可以传入一个列名的列表，来识别重复值。

```python
In [276]: df2.duplicated(['a', 'b'])
Out[276]:
0    False
1    False
2    False
3    False
4     True
5    False
6    False
dtype: bool

In [277]: df2.drop_duplicates(['a', 'b'])
Out[277]:
       a  b         c
0    one  x -1.067137
1    one  y  0.309500
2    two  x -0.211056
3    two  y -1.842023
5  three  x -1.964475
6   four  x  1.298329
```

要按索引值删除重复项，请使用`Index.duplicated`，然后执行切片。` keep`参数可以使用相同的选项集。

```python
In [278]: df3 = pd.DataFrame({'a': np.arange(6),
   .....:                     'b': np.random.randn(6)},
   .....:                    index=['a', 'a', 'b', 'c', 'b', 'a'])
   .....:

In [279]: df3
Out[279]:
   a         b
a  0  1.440455
a  1  2.456086
b  2  1.038402
c  3 -0.894409
b  4  0.683536
a  5  3.082764

In [280]: df3.index.duplicated()
Out[280]: array([False,  True, False, False,  True,  True], dtype=bool)

In [281]: df3[~df3.index.duplicated()]
Out[281]:
   a         b
a  0  1.440455
b  2  1.038402
c  3 -0.894409

In [282]: df3[~df3.index.duplicated(keep='last')]
Out[282]:
   a         b
c  3 -0.894409
b  4  0.683536
a  5  3.082764

In [283]: df3[~df3.index.duplicated(keep=False)]
Out[283]:
   a         b
c  3 -0.894409
```

#### 12.18 类似字典的[`get()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.get.html#pandas.DataFrame.get)方法

Series、DataFrame和Panel都有一个`get`方法，该方法可以返回一个默认值。

```python
In [284]: s = pd.Series([1,2,3], index=['a','b','c'])

In [285]: s.get('a')               # equivalent to s['a']
Out[285]: 1

In [286]: s.get('x', default=-1)
Out[286]: -1
```

#### 12.19  [`lookup()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.lookup.html#pandas.DataFrame.lookup)方法

有时，你希望在给定一系列行标签和列标签的情况下提取一组值，并且`lookup`方法允许此操作并返回NumPy数组。 例如：

```python
In [287]: dflookup = pd.DataFrame(np.random.rand(20,4), columns = ['A','B','C','D'])

In [288]: dflookup.lookup(list(range(0,10,2)), ['B','C','A','B','D'])
Out[288]: array([ 0.3506,  0.4779,  0.4825,  0.9197,  0.5019])
```

#### 12.20 Index对象

可以将Pandas的及其子类看成一个有序多集的实现。允许重复。不过，如果你想将有重复值的 [`Index`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.Index.html#pandas.Index)对象转换成一个`set`，将会触发异常。

 [`Index`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.Index.html#pandas.Index)也提供查找、数据对齐和重建索引所需的基础结构。直接创建 [`Index`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.Index.html#pandas.Index)的最简单方法是将列表或其他序列传递给 [`Index`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.Index.html#pandas.Index)：

```python
In [289]: index = pd.Index(['e', 'd', 'a', 'b'])

In [290]: index
Out[290]: Index(['e', 'd', 'a', 'b'], dtype='object')

In [291]: 'd' in index
Out[291]: True
```

你也可以传入要存储在索引中的名称：

```python
In [292]: index = pd.Index(['e', 'd', 'a', 'b'], name='something')

In [293]: index.name
Out[293]: 'something'
```

这个名称（如果设置了），将会在控制台中展示。

```python
In [294]: index = pd.Index(list(range(5)), name='rows')

In [295]: columns = pd.Index(['A', 'B', 'C'], name='cols')

In [296]: df = pd.DataFrame(np.random.randn(5, 3), index=index, columns=columns)

In [297]: df
Out[297]:
cols         A         B         C
rows                              
0     1.295989  0.185778  0.436259
1     0.678101  0.311369 -0.528378
2    -0.674808 -1.103529 -0.656157
3     1.889957  2.076651 -1.102192
4    -1.211795 -0.791746  0.634724

In [298]: df['A']
Out[298]:
rows
0    1.295989
1    0.678101
2   -0.674808
3    1.889957
4   -1.211795
Name: A, dtype: float64
```

##### 12.20.1 设置元数据

索引在大部分情况下是不可变的，但是，可以改变它们的元数据，例如：`name`，或者多重索引的`levels`和`labels`。

你可以使用`rename`，`set_names`，`set_levels`和`set_labels`来直接修改这些属性。默认地，操作之后返回原数据的一个副本，不过，你也可以使用`inplace=True`来修改原数据。

从[Advanced Indexing](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced)查看多重索引的使用方式。

```python
In [299]: ind = pd.Index([1, 2, 3])

In [300]: ind.rename("apple")
Out[300]: Int64Index([1, 2, 3], dtype='int64', name='apple')

In [301]: ind
Out[301]: Int64Index([1, 2, 3], dtype='int64')

In [302]: ind.set_names(["apple"], inplace=True)

In [303]: ind.name = "bob"

In [304]: ind
Out[304]: Int64Index([1, 2, 3], dtype='int64', name='bob')
```

`set_names`，`set_levels`和`set_labels`还有一个`level`参数：

```python
In [305]: index = pd.MultiIndex.from_product([range(3), ['one', 'two']], names=['first', 'second'])

In [306]: index
Out[306]:
MultiIndex(levels=[[0, 1, 2], ['one', 'two']],
           labels=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
           names=['first', 'second'])

In [307]: index.levels[1]
Out[307]: Index(['one', 'two'], dtype='object', name='second')

In [308]: index.set_levels(["a", "b"], level=1)
Out[308]:
MultiIndex(levels=[[0, 1, 2], ['a', 'b']],
           labels=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
           names=['first', 'second'])
```

##### 12.20.2  index对象间的集合操作

index对象间的集合操作主要有两个：`union(|)`和`intersection(&)`。它们可以直接作为实例方法或通过重载操作符调用。差异判断是通过`.difference()`操作来实现的。

```python
In [309]: a = pd.Index(['c', 'b', 'a'])

In [310]: b = pd.Index(['c', 'e', 'd'])

In [311]: a | b
Out[311]: Index(['a', 'b', 'c', 'd', 'e'], dtype='object')

In [312]: a & b
Out[312]: Index(['c'], dtype='object')

In [313]: a.difference(b)
Out[313]: Index(['a', 'b'], dtype='object')
```

还有一种操作：`symmetric_difference(^)`，返回在idx1或idx2中存在，但不同时在两个index中存在的元素，等价于：`idx1.difference(idx2).union(idx2.difference(idx1))`操作之后再去重。

```python
In [314]: idx1 = pd.Index([1, 2, 3, 4])

In [315]: idx2 = pd.Index([2, 3, 4, 5])

In [316]: idx1.symmetric_difference(idx2)
Out[316]: Int64Index([1, 5], dtype='int64')

In [317]: idx1 ^ idx2
Out[317]: Int64Index([1, 5], dtype='int64')
```

> 注意：集合操作的结果会按照升序排列。

##### 12.20.3  缺失数据

**重要：**虽然Index可以操作缺失数据（NaN），但是如果不想遇到不可预期的结果，尽量避免这么操作。比如，有些操作会隐式地排除缺失数据。

`Index.fillna`将缺失数据填充为指定的标量值。

```python
In [318]: idx1 = pd.Index([1, np.nan, 3, 4])

In [319]: idx1
Out[319]: Float64Index([1.0, nan, 3.0, 4.0], dtype='float64')

In [320]: idx1.fillna(2)
Out[320]: Float64Index([1.0, 2.0, 3.0, 4.0], dtype='float64')

In [321]: idx2 = pd.DatetimeIndex([pd.Timestamp('2011-01-01'), pd.NaT, pd.Timestamp('2011-01-03')])

In [322]: idx2
Out[322]: DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'], dtype='datetime64[ns]', freq=None)

In [323]: idx2.fillna(pd.Timestamp('2011-01-02'))
Out[323]: DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03'], dtype='datetime64[ns]', freq=None)
```

#### 12.21 设置 / 重新设置Index

有时候，你创建好了一个DataFrame之后，还想添加一个索引。有许多方法可以达效果：

##### 12.21.1 设置索引

Dataframe有一个[`set_index()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index)方法，这个方法接受一个列名（用来设置Index）或一个列名列表（用来设置MultiIndex）。创建一个新的重新设置索引的DataFrame：

```python
In [324]: data
Out[324]:
     a    b  c    d
0  bar  one  z  1.0
1  bar  two  y  2.0
2  foo  one  x  3.0
3  foo  two  w  4.0

In [325]: indexed1 = data.set_index('c')

In [326]: indexed1
Out[326]:
     a    b    d
c               
z  bar  one  1.0
y  bar  two  2.0
x  foo  one  3.0
w  foo  two  4.0

In [327]: indexed2 = data.set_index(['a', 'b'])

In [328]: indexed2
Out[328]:
         c    d
a   b          
bar one  z  1.0
    two  y  2.0
foo one  x  3.0
    two  w  4.0
```

`append`关键字允许保持已经存在的Index，而把新加的列添加到MultiIndex。

```python
In [329]: frame = data.set_index('c', drop=False)

In [330]: frame = frame.set_index(['a', 'b'], append=True)

In [331]: frame
Out[331]:
           c    d
c a   b          
z bar one  z  1.0
y bar two  y  2.0
x foo one  x  3.0
w foo two  w  4.0
```

`set_index`的其他选项允许你不丢弃原来的索引列，或就地添加索引（不创建新的对象）：

```python
In [332]: data.set_index('c', drop=False)
Out[332]:
     a    b  c    d
c                  
z  bar  one  z  1.0
y  bar  two  y  2.0
x  foo  one  x  3.0
w  foo  two  w  4.0

In [333]: data.set_index(['a', 'b'], inplace=True)

In [334]: data
Out[334]:
         c    d
a   b          
bar one  z  1.0
    two  y  2.0
foo one  x  3.0
    two  w  4.0
```

##### 12.21.2 重新设置索引

DataFrame上有一个更方便的函数叫做[`reset_index()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index) ，它可以将索引数据转换为DataFrame的列，并且设置一个简单的整型索引。它是 [`set_index()`](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index)的反方法。

```python
In [335]: data
Out[335]:
         c    d
a   b          
bar one  z  1.0
    two  y  2.0
foo one  x  3.0
    two  w  4.0

In [336]: data.reset_index()
Out[336]:
     a    b  c    d
0  bar  one  z  1.0
1  bar  two  y  2.0
2  foo  one  x  3.0
3  foo  two  w  4.0
```

输出更像是SQL表或记录数组。从索引中得到的列的名称保存在`names`属性中。

可以使用`level`关键字只移除一部分索引。

```python
In [337]: frame
Out[337]:
           c    d
c a   b          
z bar one  z  1.0
y bar two  y  2.0
x foo one  x  3.0
w foo two  w  4.0

In [338]: frame.reset_index(level=1)
Out[338]:
         a  c    d
c b               
z one  bar  z  1.0
y two  bar  y  2.0
x one  foo  x  3.0
w two  foo  w  4.0
```

`reset_index`有一个`drop`参数，这个参数如果为True，将会简单地丢弃索引，而不是把索引的数据放到DataFrame的列里。

##### 12.21.3 添加临时索引

如果你自己创建索引，可以将其赋值给index字段：

```python
data.index = index
```

#### 12.22 返回视图 VS 返回副本

当在一个Pandas对象上设置数据时，必须小心避免所谓的链式索引（`chained indexing`）。这里有个示例：

```python
In [339]: dfmi = pd.DataFrame([list('abcd'),
   .....:                      list('efgh'),
   .....:                      list('ijkl'),
   .....:                      list('mnop')],
   .....:                     columns=pd.MultiIndex.from_product([['one','two'],
   .....:                                                         ['first','second']]))
   .....:

In [340]: dfmi
Out[340]:
    one          two       
  first second first second
0     a      b     c      d
1     e      f     g      h
2     i      j     k      l
3     m      n     o      p
```

对比下面的两个方法：

```python
In [341]: dfmi['one']['second']
Out[341]:
0    b
1    f
2    j
3    n
Name: second, dtype: object
```

```python
In [342]: dfmi.loc[:,('one','second')]
Out[342]:
0    b
1    f
2    j
3    n
Name: (one, second), dtype: object
```

这两个方法产生同样的结果，那么应该使用哪种呢？理解这两种操作操作的执行顺序以及为什么第二种方法（.loc）比第一种方法（[]链式操作）更受欢迎，这具有指导意义。

`dfmi['one']`先选择列的第一层级，返回一个单索引的DataFrame，然后另一个Python操作`dfmi_with_on['second']`以索引`second`选择了一个Series。以`dfmi_with_on`来表示是因为pandas将这些操作视为独立事件。比如，单独调用`__getitem__`，所以必须把它们当作线性操作，一个接一个的执行。

 与此形成对比的是，`df.loc[:,('one','second')]`将嵌套的元组` (slice(None),('one','second'))`传递给`__getitem__`单独调用。这允许pandas将它处理成一个单独的实体。这种操作会显著加快，并且如果需要的话，还可以索引两个轴。

 #### 12.23 为什么使用链式索引时赋值会失败

 上一节提到的这个问题实际上是性能问题。`SettingWithCopy`是怎么回事？当您做一些可能需要额外几毫秒的事情时，我们通常不会抛出警告。

 但链式索引赋值会产生不可预测的结果。要了解这一点，请考虑Python解释器如何执行这段代码：
 ```python
 dfmi.loc[:,('one','second')] = value
# becomes
dfmi.loc.__setitem__((slice(None), ('one', 'second')), value)
 ```
但下面的代码的处理方式不同：
```python
dfmi['one']['second'] = value
# becomes
dfmi.__getitem__('one').__setitem__('second', value)
```
看到这里的`__getitem`了吗？复杂情况下，很难预料某个操作是返回视图还是返回副本（取决于数组的内存布局，而Pandas对此没有保证），因此，`__setitem__`会修改`dfmi`还是立即抛出一个临时对象也很难预料，这就是抛出警告的原因。

> 注意：你可能会关心我们是否应该关注第一个示例中的`loc`属性。但是，`dfmi.loc`保证了`dfmi`的索引修改行为，因此，`dfmi.loc.__getitem__/dfmi.loc.__setitem__`将直接操作`dfmi`。当然，`dfmi.loc.__getitem__(idx)`有可能是`dfmi`的一个视图也有可能是一个副本。

有时，当没有明显的链式索引时，也可能抛出`SettingWithCopy`警告。这些是`SettingWithCopy`设计用来捕获的BUG。如果你这么操作，Pandas将会警告你：
```python
def do_something(df):
   foo = df[['bar', 'baz']]  # Is foo a view? A copy? Nobody knows!
   # ... many lines here ...
   foo['quux'] = value       # We don't know whether this will modify df or not!
   return foo
```
#### 12.3 计算顺序很重要
使用链式索引时，索引操作的顺序和类型会部分确定结果是原始对象的切片还是切片的副本。

Pandas有一个`SettingWithCopyWarning`，因为给一个切片的副本赋值经常不是故意的，但是链式索引引发的错误在本该返回切片的地方返回了副本。

如果你希望Pandas或多或少信任链式索引的赋值，可以将`mode.chained_assignment`设置为如下值之一：
-  `warn`，默认值，意味着将会打印`SettingWithCopyWarning`。
-  `raise`，意味着Pandas将会引发一个必须处理的`SettingWithCopyException`。
-  `None`，禁止警告。

```python
In [343]: dfb = pd.DataFrame({'a' : ['one', 'one', 'two',
   .....:                            'three', 'two', 'one', 'six'],
   .....:                     'c' : np.arange(7)})
   .....: 

# This will show the SettingWithCopyWarning
# but the frame values will be set
In [344]: dfb['c'][dfb.a.str.startswith('o')] = 42
```
但是这是在副本上操作，并且不会见效
```python
>>> pd.set_option('mode.chained_assignment','warn')
>>> dfb[dfb.a.str.startswith('o')]['c'] = 42
Traceback (most recent call last)
     ...
SettingWithCopyWarning:
     A value is trying to be set on a copy of a slice from a DataFrame.
     Try using .loc[row_index,col_indexer] = value instead
```
在混合dtype frame中也可能突然出现链式赋值。
> 注意：这些设置规则适用于`.loc/.iloc`。

这是正确的访问方法：
```python
In [345]: dfc = pd.DataFrame({'A':['aaa','bbb','ccc'],'B':[1,2,3]})
In [346]: dfc.loc[0,'A'] = 11
In [347]: dfc
Out[347]: 
     A  B
0   11  1
1  bbb  2
2  ccc  3
```
这有时会起作用，但不能保证，因此应当避免。
```python
In [348]: dfc = dfc.copy()
In [349]: dfc['A'][0] = 111
In [350]: dfc
Out[350]: 
     A  B
0  111  1
1  bbb  2
2  ccc  3
```
这根本不起作用，因此应当避免：
```python
>>> pd.set_option('mode.chained_assignment','raise')
>>> dfc.loc[0]['A'] = 1111
Traceback (most recent call last)
     ...
SettingWithCopyException:
     A value is trying to be set on a copy of a slice from a DataFrame.
     Try using .loc[row_index,col_indexer] = value instead
```
> 警告：链式赋值警告或异常旨在提示用户可能无效的赋值。可能存在假阳性，意外报告链式赋值的情况。