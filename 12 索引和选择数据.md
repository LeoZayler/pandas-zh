### 索引和选择数据

Pandas对象的轴标签信息能够提供很多功能：

- 使用已知的索引器标识数据（例如：提供元数据），这在数据分析，可视化和交互式终端显示中很重要。
- 支持自动地、明确地数据对齐。
- 允许直观地获取、设置数据子集。

本章我们将聚焦在最后一点，即如何切片、切块、一般的获取和设置Pandas对象的子集，主要关注的是Series和DataFrame，因为它们在这个领域受到更多的开发关注。

> 注意：Python和Numpy的索引操作符`[]`提供了快速、简单的广泛使用的访问Pandas数据结构的方法。这使得交互式工作变得直观，因为如果已经知道如何使用Python字典和Numpy数组，几乎不需要学习什么新的东西。不过，因为待访问的数据的类型不会提前知道，直接使用标准的操作符有一些优化限制。在生产代码中，我们建议你优先使用本章中介绍的优化的Pandas数据访问方法。

> 警告：设置操作返回一个副本还是引用，可能取决于上下文。这有时称为`chained assignment`，并且应该避免。查看[Returning a View versus Copy](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-view-versus-copy)获得更多信息。

> 警告：使用浮点数对基于整数的索引进行索引的操作已在0.18.0版本中进行了说明，有关修改的摘要，请查看[这里](http://pandas.pydata.org/pandas-docs/version/0.23/whatsnew.html#whatsnew-0180-float-indexers)。

查看[MultiIndex / Advanced Indexing](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced)获得关于MultiIndex和更多的高级索引的文档。

查看 [cookbook](http://pandas.pydata.org/pandas-docs/version/0.23/cookbook.html#cookbook-selection)获得一些高级使用方法。

#### 12.1 不同的索引选择

对象选择操作已经有一些用户请求的添加，以支持更明确的基于位置的索引。Pandas现在支持三种多轴索引：

- `.loc`是主要的基于标签的索引方式。但是，也可以和布尔数组一起使用。当没有找到元素时，`.loc`将抛出`KeyError`。允许的输入有：

  - 单独的标签，比如`5`或`a`（注意：`5`会被解释为index标签，这种用法`不是`index 的整数位置）。
  - 标签列表或数组`['a', 'b', 'c', 'd']`。
  - 标签切片对象`'a':'f'`（注意：与通常的Python切片相反，在索引中使用时，包含开始和结束，查看[按标签索引](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-slicing-with-labels)）。
  - 布尔数组。
  - 单一参数（可调用的Series、DataFrame或Panel）、返回合法的支持索引的输出（上述几项中的一项）的可调用函数。

  查看[按标签选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-label)获得更多信息。

- `.iloc`是主要的基于位置（0到轴的长度-1）的索引方式。但是，也可以和布尔数组一起使用。如果请求的索引器超出了范围，`iloc`将会抛出`IndexError`，除非切片索引器允许越界索引。这符合Python或Numpy的切片语义。允许的输入有：

  - 整数，例如`5`。

  - 整数列表或数组：`[4, 3, 0]`。

  - 带有整数的切片对象：`1:7`。

  - 布尔数组。

  - 单一参数（可调用的Series、DataFrame或Panel）、返回合法的支持索引的输出（上述几项中的一项）的可调用函数。

    查看[按位置选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-integer)，[高级索引](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced)和[高级分层](http://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced-advanced-hierarchical)获得更多信息。

- `.loc`，`.iloc`和`[]`索引方式都接受一个可调用对象作为索引器。查看[按可调用对象选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-callable)获得更多信息。

从具有多轴选择的对象获取值使用以下符号（以使用`.loc`为例，使用`.iloc`也同样适用）。每个轴的访问器都有可能是空的切片`:`，未指定的轴为被假定为`:`，例如，`p.loc['a']`等价于`p.loc['a',:,:]`。

| 对象类型  | 索引器                                            |
| --------- | ------------------------------------------------- |
| Series    | `s.loc[indexer]`                                  |
| DataFrame | `df.loc[row_indexer,column_indexer]`              |
| Panel     | `p.loc[item_indexer,major_indexer,minor_indexer]` |

#### 12.2 基本操作

就像在介绍数据结构时的[最后一节](http://pandas.pydata.org/pandas-docs/version/0.23/basics.html#basics)中提到的，使用`[]`（对于熟悉在Python中实现类行为的人来说又称作`__getitem__`）索引的主要函数是选出低维切片。下面的表格展示了使用`[]`索引Pandas对象时的返回类型:

| 对象类型  | 选择              | 返回值类型               |
| --------- | ----------------- | ------------------------ |
| Series    | `series[label]`   | 标量值                   |
| DataFrame | `frame[colname]`  | 对应列名的Series         |
| Panel     | `panel[itemname]` | 对应 itemname的DataFrame |

我们构造了一个简单的时间序列数据集，来说明索引功能：

```python
In [1]: dates = pd.date_range('1/1/2000', periods=8)

In [2]: df = pd.DataFrame(np.random.randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])

In [3]: df
Out[3]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885

In [4]: panel = pd.Panel({'one' : df, 'two' : df - df.mean()})

In [5]: panel
Out[5]: 
<class 'pandas.core.panel.Panel'>
Dimensions: 2 (items) x 8 (major_axis) x 4 (minor_axis)
Items axis: one to two
Major_axis axis: 2000-01-01 00:00:00 to 2000-01-08 00:00:00
Minor_axis axis: A to D
```

> 注意：除非特别说明，否则索引功能都不是时间序列特有的。

因此，如上所述，我们使用`[]`进行大部分基本索引：

```python
In [6]: s = df['A']

In [7]: s[dates[5]]
Out[7]: -0.67368970808837059

In [8]: panel['two']
Out[8]: 
                   A         B         C         D
2000-01-01  0.409571  0.113086 -0.610826 -0.936507
2000-01-02  1.152571  0.222735  1.017442 -0.845111
2000-01-03 -0.921390 -1.708620  0.403304  1.270929
2000-01-04  0.662014 -0.310822 -0.141342  0.470985
2000-01-05 -0.484513  0.962970  1.174465 -0.888276
2000-01-06 -0.733231  0.509598 -0.580194  0.724113
2000-01-07  0.345164  0.972995 -0.816769 -0.840143
2000-01-08 -0.430188 -0.761943 -0.446079  1.044010
```

你可以传入列名组成的列表来按照顺序选择那些列。如果某个类没有包含的DataFrame中，会触发异常。也可以用这种方式设置多列。

```python
In [9]: df
Out[9]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885

In [10]: df[['B', 'A']] = df[['A', 'B']]

In [11]: df
Out[11]: 
                   A         B         C         D
2000-01-01 -0.282863  0.469112 -1.509059 -1.135632
2000-01-02 -0.173215  1.212112  0.119209 -1.044236
2000-01-03 -2.104569 -0.861849 -0.494929  1.071804
2000-01-04 -0.706771  0.721555 -1.039575  0.271860
2000-01-05  0.567020 -0.424972  0.276232 -1.087401
2000-01-06  0.113648 -0.673690 -1.478427  0.524988
2000-01-07  0.577046  0.404705 -1.715002 -1.039268
2000-01-08 -1.157892 -0.370647 -1.344312  0.844885
```

你可能发现，这在对列的子集进行就地变换时很有用。

> 警告：当使用`.loc`或`.iloc`设置Series或DataFrame时，Pandas会对齐所有轴。这不会修改`df`，因为对齐在赋值之前。
>
> ```pyhton
> In [12]: df[['A', 'B']]
> Out[12]: 
>                    A         B
> 2000-01-01 -0.282863  0.469112
> 2000-01-02 -0.173215  1.212112
> 2000-01-03 -2.104569 -0.861849
> 2000-01-04 -0.706771  0.721555
> 2000-01-05  0.567020 -0.424972
> 2000-01-06  0.113648 -0.673690
> 2000-01-07  0.577046  0.404705
> 2000-01-08 -1.157892 -0.370647
> 
> In [13]: df.loc[:,['B', 'A']] = df[['A', 'B']]
> 
> In [14]: df[['A', 'B']]
> Out[14]: 
>                    A         B
> 2000-01-01 -0.282863  0.469112
> 2000-01-02 -0.173215  1.212112
> 2000-01-03 -2.104569 -0.861849
> 2000-01-04 -0.706771  0.721555
> 2000-01-05  0.567020 -0.424972
> 2000-01-06  0.113648 -0.673690
> 2000-01-07  0.577046  0.404705
> 2000-01-08 -1.157892 -0.370647
> ```
>
> 正确的交换列值的方式是使用原始值：
>
> ```python
> In [15]: df.loc[:,['B', 'A']] = df[['A', 'B']].values
> 
> In [16]: df[['A', 'B']]
> Out[16]: 
>                    A         B
> 2000-01-01  0.469112 -0.282863
> 2000-01-02  1.212112 -0.173215
> 2000-01-03 -0.861849 -2.104569
> 2000-01-04  0.721555 -0.706771
> 2000-01-05 -0.424972  0.567020
> 2000-01-06 -0.673690  0.113648
> 2000-01-07  0.404705  0.577046
> 2000-01-08 -0.370647 -1.157892
> ```

#### 12.3 访问属性

你可能以访问属性的方式访问Series的索引，DataFrame的列和Panel的Item。

```python
In [17]: sa = pd.Series([1,2,3],index=list('abc'))

In [18]: dfa = df.copy()
```

```python
In [19]: sa.b
Out[19]: 2

In [20]: dfa.A
Out[20]: 
2000-01-01    0.469112
2000-01-02    1.212112
2000-01-03   -0.861849
2000-01-04    0.721555
2000-01-05   -0.424972
2000-01-06   -0.673690
2000-01-07    0.404705
2000-01-08   -0.370647
Freq: D, Name: A, dtype: float64

In [21]: panel.one
Out[21]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885
```

```python
In [22]: sa.a = 5

In [23]: sa
Out[23]: 
a    5
b    2
c    3
dtype: int64

In [24]: dfa.A = list(range(len(dfa.index)))  # ok if A already exists

In [25]: dfa
Out[25]: 
            A         B         C         D
2000-01-01  0 -0.282863 -1.509059 -1.135632
2000-01-02  1 -0.173215  0.119209 -1.044236
2000-01-03  2 -2.104569 -0.494929  1.071804
2000-01-04  3 -0.706771 -1.039575  0.271860
2000-01-05  4  0.567020  0.276232 -1.087401
2000-01-06  5  0.113648 -1.478427  0.524988
2000-01-07  6  0.577046 -1.715002 -1.039268
2000-01-08  7 -1.157892 -1.344312  0.844885

In [26]: dfa['A'] = list(range(len(dfa.index)))  # use this form to create a new column

In [27]: dfa
Out[27]: 
            A         B         C         D
2000-01-01  0 -0.282863 -1.509059 -1.135632
2000-01-02  1 -0.173215  0.119209 -1.044236
2000-01-03  2 -2.104569 -0.494929  1.071804
2000-01-04  3 -0.706771 -1.039575  0.271860
2000-01-05  4  0.567020  0.276232 -1.087401
2000-01-06  5  0.113648 -1.478427  0.524988
2000-01-07  6  0.577046 -1.715002 -1.039268
2000-01-08  7 -1.157892 -1.344312  0.844885
```

> 警告：
>
> - 只有索引元素是合法的Python识别码时才可以用这种方式访问。例如不允许使用`s.1`，查看[这里](https://docs.python.org/3/reference/lexical_analysis.html#identifiers)了解合法的识别码的解释。
> - 当属性和已经存在方法名冲突时，不能访问。例如不允许使用`s.min`。
> - 当属性和`index, major_axis, minor_axis, items`冲突时，也不能访问。
> - 上述几种情况，使用保准的索引方式都是可行的。例如`s['a']`，`s['min']`，`s['index']`会访问对应的元素或列。

如果你正在使用IPython环境，你可以使用`tab`自动补全功能来查看所有看访问的属性。

你也可以用一个字典为DataFrame的一行赋值。

```python
In [28]: x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})

In [29]: x.iloc[1] = dict(x=9, y=99)

In [30]: x
Out[30]: 
   x   y
0  1   3
1  9  99
2  3   5
```

你可以使用属性访问来修改一个已经存在的Series的元素或DataFrame的列，但是要注意，如果你尝试使用属性访问来创建一个新的列，它会创建一个新的属性，而不是一个新的列。在0.21.0及以后的版本，这将会抛出一个`UserWarning`。

```python
In[1]: df = pd.DataFrame({'one': [1., 2., 3.]})
In[2]: df.two = [4, 5, 6]
UserWarning: Pandas doesn't allow Series to be assigned into nonexistent columns - see https://pandas.pydata.org/pandas-docs/stable/indexing.html#attribute_access
In[3]: df
Out[3]:
   one
0  1.0
1  2.0
2  3.0
```

#### 12.4 切割范围

沿着任意轴切割范围的最稳健和一致的方法在[按位置选择](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-integer)的部分会介绍详细介绍`.iloc`方法。现在，我们解释一下使用`[]`操作符切片的语义。

对于Series，这个语法和Numpy数组的工作方式一样，返回Series的值的一部分和对应的标签。

```pyhton
In [31]: s[:5]
Out[31]: 
2000-01-01    0.469112
2000-01-02    1.212112
2000-01-03   -0.861849
2000-01-04    0.721555
2000-01-05   -0.424972
Freq: D, Name: A, dtype: float64

In [32]: s[::2]
Out[32]: 
2000-01-01    0.469112
2000-01-03   -0.861849
2000-01-05   -0.424972
2000-01-07    0.404705
Freq: 2D, Name: A, dtype: float64

In [33]: s[::-1]
Out[33]: 
2000-01-08   -0.370647
2000-01-07    0.404705
2000-01-06   -0.673690
2000-01-05   -0.424972
2000-01-04    0.721555
2000-01-03   -0.861849
2000-01-02    1.212112
2000-01-01    0.469112
Freq: -1D, Name: A, dtype: float64
```

注意，设置操作同样也可以工作

```python
In [34]: s2 = s.copy()

In [35]: s2[:5] = 0

In [36]: s2
Out[36]: 
2000-01-01    0.000000
2000-01-02    0.000000
2000-01-03    0.000000
2000-01-04    0.000000
2000-01-05    0.000000
2000-01-06   -0.673690
2000-01-07    0.404705
2000-01-08   -0.370647
Freq: D, Name: A, dtype: float64
```

对应DataFrame，`[]`的内部切片是在切割行。这主要是为了方便，因为这是非常常见的操作。

```python
In [37]: df[:3]
Out[37]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804

In [38]: df[::-1]
Out[38]: 
                   A         B         C         D
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
```

#### 12.5 使用标签选择

> 警告：设置操作返回一个副本还是引用，可能取决于上下文。这有时称为`chained assignment`，并且应该避免。查看[Returning a View versus Copy](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-view-versus-copy)获得更多信息。

> 警告：当使用的的切片器和索引类型不兼容（或可转换）时，`.loc`是严格的。例如，在DatatimeIndex中使用整数，这将抛出`TypeError`。
>
> ```python
> In [39]: dfl = pd.DataFrame(np.random.randn(5,4), columns=list('ABCD'), index=pd.date_range('20130101',periods=5))
> 
> In [40]: dfl
> Out[40]: 
>                    A         B         C         D
> 2013-01-01  1.075770 -0.109050  1.643563 -1.469388
> 2013-01-02  0.357021 -0.674600 -1.776904 -0.968914
> 2013-01-03 -1.294524  0.413738  0.276662 -0.472035
> 2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061
> 2013-01-05  0.895717  0.805244 -1.206412  2.565646
> ```
>
> ```python
> In [4]: dfl.loc[2:3]
> TypeError: cannot do slice indexing on <class 'pandas.tseries.index.DatetimeIndex'> with these indexers [2] of <type 'int'>
> ```
>
> 索引中的类字符串可以转换成index的类型，并且得到自然切片
>
> ```python
> In [41]: dfl.loc['20130102':'20130104']
> Out[41]: 
>                    A         B         C         D
> 2013-01-02  0.357021 -0.674600 -1.776904 -0.968914
> 2013-01-03 -1.294524  0.413738  0.276662 -0.472035
> 2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061
> ```
>
> > 警告：从0.21.0版开始，如果用包含缺失标签的列表进行索引时，Pandas将显示`FutureWarning`。将来，这将会抛出`KeyError`。查看 [list-like Using loc with missing keys in a list is Deprecated](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-deprecate-loc-reindex-listlike)获得更多信息。

