### 13 多重索引和高级索引
本章将介绍MultiIndex的索引方法以及一些高级的索引技巧。
你可以从[索引和选择数据](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing)章节查看基本的索引方法。
> 警告：设置操作返回一个副本还是一个引用取决于不同的环境。有时这叫做链式赋值，应该尽量避免，查看[返回视图或副本](http://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-view-versus-copy)。

从[cookbook](http://pandas.pydata.org/pandas-docs/version/0.23/cookbook.html#cookbook-selection)查看高级策略。

#### 13.1 分层索引（MultiIndex)
分层/分级索引令人兴奋，因为它为复杂的数据分析和操作，尤其是操作高维数据打开了一扇门。本质上，它令你可以在低纬数据结构（一维的Series，二维的DataFrame）中存储和处理任意维度的数据。
本章，我们将展示什么是分层索引，以及如何将它与前面章节提到的索引方法相结合。稍后，当我们讨论[分组](http://pandas.pydata.org/pandas-docs/version/0.23/groupby.html#groupby)、[透视表和重塑数据](http://pandas.pydata.org/pandas-docs/version/0.23/reshaping.html#reshaping)时，我们将展示重要的应用来说明它如何帮助结构化数据分析。

从[cookbook](http://pandas.pydata.org/pandas-docs/version/0.23/cookbook.html#cookbook-selection)查看高级策略。

##### 13.1.1 创建MultiIndex(分层索引)对象

`MultiIndex`对象是通常将轴标签存储在Pandas对象中的标准`Index`对象的分层模拟。你可以把`MultiIndex`想象成一个元组数组，其中每个元组都是唯一的。`MultiIndex`可以用一组数组（使用`MultiIndex.from_arrays`）、一组元组（使用`MultiIndex.from_tuples`）或用一组相交的迭代器（使用`MultiIndex.from_product`）来生成。当传入一个元组数组时，`Index`构造器将尝试返回一个`MultiIndex`。下面的示例展示了初始化多重索引的的不同方法。

```Python
In [1]: arrays = [['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'],
   ...:           ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]
   ...: 

In [2]: tuples = list(zip(*arrays))

In [3]: tuples
Out[3]: 
[('bar', 'one'),
 ('bar', 'two'),
 ('baz', 'one'),
 ('baz', 'two'),
 ('foo', 'one'),
 ('foo', 'two'),
 ('qux', 'one'),
 ('qux', 'two')]

In [4]: index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])

In [5]: index
Out[5]: 
MultiIndex(levels=[['bar', 'baz', 'foo', 'qux'], ['one', 'two']],
           labels=[[0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 0, 1, 0, 1, 0, 1]],
           names=['first', 'second'])

In [6]: s = pd.Series(np.random.randn(8), index=index)

In [7]: s
Out[7]: 
first  second
bar    one       0.469112
       two      -0.282863
baz    one      -1.509059
       two      -1.135632
foo    one       1.212112
       two      -0.173215
qux    one       0.119209
       two      -1.044236
dtype: float64
```

当你希望使用两个迭代器中的每一对元素时，使用MultiIndex.from product函数会更容易。

```python
In [8]: iterables = [['bar', 'baz', 'foo', 'qux'], ['one', 'two']]

In [9]: pd.MultiIndex.from_product(iterables, names=['first', 'second'])
Out[9]: 
MultiIndex(levels=[['bar', 'baz', 'foo', 'qux'], ['one', 'two']],
           labels=[[0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 0, 1, 0, 1, 0, 1]],
           names=['first', 'second'])
```

作为一种便利手段，你可以向一个Series或DataFrame中传入一个数组列表来自动构造多重索引。

```Python
In [10]: arrays = [np.array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux']),
   ....:           np.array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'])]
   ....: 

In [11]: s = pd.Series(np.random.randn(8), index=arrays)

In [12]: s
Out[12]: 
bar  one   -0.861849
     two   -2.104569
baz  one   -0.494929
     two    1.071804
foo  one    0.721555
     two   -0.706771
qux  one   -1.039575
     two    0.271860
dtype: float64

In [13]: df = pd.DataFrame(np.random.randn(8, 4), index=arrays)

In [14]: df
Out[14]: 
                0         1         2         3
bar one -0.424972  0.567020  0.276232 -1.087401
    two -0.673690  0.113648 -1.478427  0.524988
baz one  0.404705  0.577046 -1.715002 -1.039268
    two -0.370647 -1.157892 -1.344312  0.844885
foo one  1.075770 -0.109050  1.643563 -1.469388
    two  0.357021 -0.674600 -1.776904 -0.968914
qux one -1.294524  0.413738  0.276662 -0.472035
    two -0.013960 -0.362543 -0.006154 -0.923061
```

所有的`MultiIndex`构造器都接受一个`names`参数，用来保存索引中每一层的字符串名称。如果不传入`names`，将被赋值为None。

```Python
In [15]: df.index.names
Out[15]: FrozenList([None, None])
```

索引支持pandas对象的任何轴，索引的级别由你来定。

```Python
In [16]: df = pd.DataFrame(np.random.randn(3, 8), index=['A', 'B', 'C'], columns=index)

In [17]: df
Out[17]: 
first        bar                 baz                 foo                 qux          
second       one       two       one       two       one       two       one       two
A       0.895717  0.805244 -1.206412  2.565646  1.431256  1.340309 -1.170299 -0.226169
B       0.410835  0.813850  0.132003 -0.827317 -0.076467 -1.187678  1.130127 -1.436737
C      -1.413681  1.607920  1.024180  0.569605  0.875906 -2.211372  0.974466 -2.006747

In [18]: pd.DataFrame(np.random.randn(6, 6), index=index[:6], columns=index[:6])
Out[18]: 
first              bar                 baz                 foo          
second             one       two       one       two       one       two
first second                                                            
bar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804
      two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734
baz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738
      two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849
foo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232
      two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441
```

为了看起来舒服，我们把高级的索引进行了稀疏化。索引如何显示可以通过`pandas.set_options()`设置`multi_sparse`来控制：

```python
In [19]: with pd.option_context('display.multi_sparse', False):
   ....:     df
   ....: 
```

值得记住的是，没有什么能阻止使用元组作为某个轴上的原子标签：

```python
In [20]: pd.Series(np.random.randn(8), index=tuples)
Out[20]: 
(bar, one)   -1.236269
(bar, two)    0.896171
(baz, one)   -0.487602
(baz, two)   -0.082240
(foo, one)   -2.182937
(foo, two)    0.380396
(qux, one)    0.084844
(qux, two)    0.432390
dtype: float64
```

`MultiIndex`之所以重要，是因为它允许我们进行分组、选择和重塑操作（在本章的下面以及文档的后续部分会介绍）。在后面的部分能够看到，你可以使用多层索引而不必显式地创建它。不过，当从一个文件导入数据时，你可能希望生成自己的`MultiIndex`。

##### 13.1.2 重构标签级别

`get_level_values`返回特定级别的每个位置上标签向量。

```python
In [21]: index.get_level_values(0)
Out[21]: Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')

In [22]: index.get_level_values('second')
Out[22]: Index(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='object', name='second')
```

##### 13.1.3 `MultiIndex`基本索引方法

 分层索引的一个重要特性是，你可以通过选择能够标识数据的子组的局部标签来选择数据。 局部选择 以完全类似于在常规DataFrame中选择一列的方式降低结果中的分层索引的级别。

```python
In [23]: df['bar']
Out[23]: 
second       one       two
A       0.895717  0.805244
B       0.410835  0.813850
C      -1.413681  1.607920

In [24]: df['bar', 'one']
Out[24]: 
A    0.895717
B    0.410835
C   -1.413681
Name: (bar, one), dtype: float64

In [25]: df['bar']['one']
Out[25]: 
A    0.895717
B    0.410835
C   -1.413681
Name: one, dtype: float64

In [26]: s['qux']
Out[26]: 
one   -1.039575
two    0.271860
dtype: float64
```

通过[分层索引界面](https://pandas.pydata.org/pandas-docs/version/0.23/advanced.html#advanced-xs)来查看如何在深层级别选择数据。

##### 13.1.4 定义（索引）级别

`MultiIndex`的数据类型解释展示了一个索引上所有被定义了的级别，即使它们没有被使用。当对索引切片时，你会注意到这些。例如：

```python
In [27]: df.columns  # original MultiIndex
Out[27]: 
MultiIndex(levels=[['bar', 'baz', 'foo', 'qux'], ['one', 'two']],
           labels=[[0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 0, 1, 0, 1, 0, 1]],
           names=['first', 'second'])

In [28]: df[['foo','qux']].columns  # sliced
Out[28]: 
MultiIndex(levels=[['bar', 'baz', 'foo', 'qux'], ['one', 'two']],
           labels=[[2, 2, 3, 3], [0, 1, 0, 1]],
           names=['first', 'second'])
```

这么做避免了对索引级别的重新计算，从而提高了切片的性能。如果你只想看到被使用的（索引）级别，可以使用[`MultiIndex.get_level_values()`](https://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values)方法查看。

```python
In [29]: df[['foo','qux']].columns.values
Out[29]: array([('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')], dtype=object)

# for a specific level
In [30]: df[['foo','qux']].columns.get_level_values(0)
Out[30]: Index(['foo', 'foo', 'qux', 'qux'], dtype='object', name='first')
```

如果想用被使用的索引级别重构`MultiIndex`，可以用`remove_unused_level`方法。

0.20.0版新增。

```pyhton
In [31]: df[['foo','qux']].columns.remove_unused_levels()
Out[31]: 
MultiIndex(levels=[['foo', 'qux'], ['one', 'two']],
           labels=[[0, 0, 1, 1], [0, 1, 0, 1]],
           names=['first', 'second'])
```

##### 13.1.5 数据对齐，使用`reindex`

轴上有多个索引的不同被索引对象之间的操作将像你期望的那样，数据对齐将像元组索引那样工作。

```python
In [32]: s + s[:-2]
Out[32]: 
bar  one   -1.723698
     two   -4.209138
baz  one   -0.989859
     two    2.143608
foo  one    1.443110
     two   -1.413542
qux  one         NaN
     two         NaN
dtype: float64

In [33]: s + s[::2]
Out[33]: 
bar  one   -1.723698
     two         NaN
baz  one   -0.989859
     two         NaN
foo  one    1.443110
     two         NaN
qux  one   -2.079150
     two         NaN
dtype: float64
```

`reindex`可以使用另一个`MultiIndex`来调用，或者甚至是使用一个列表、数组或元组：

```python
In [34]: s.reindex(index[:3])
Out[34]: 
first  second
bar    one      -0.861849
       two      -2.104569
baz    one      -0.494929
dtype: float64

In [35]: s.reindex([('foo', 'two'), ('bar', 'one'), ('qux', 'one'), ('baz', 'one')])
Out[35]: 
foo  two   -0.706771
bar  one   -0.861849
qux  one   -1.039575
baz  one   -0.494929
dtype: float64
```

#### 13.2 分层索引的高级用法

在高级索引上对`MultiIndex`进行`.loc`语法整合是一个挑战。不过，我们做了所有的努力。通常，MultiIndex键采用元组的方式。例如，下面的示例会像你所想象的那样工作：

```python
In [36]: df = df.T

In [37]: df
Out[37]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

In [38]: df.loc[('bar', 'two'),]
Out[38]: 
A    0.805244
B    0.813850
C    1.607920
Name: (bar, two), dtype: float64
```

注意，在上面的示例中，`df.loc['bar', 'two']`一样可以工作，但是这种简写容易引起歧义。

如果你想用`.loc`来索引一列，必须像下面这样使用：

```python
In [39]: df.loc[('bar', 'two'), 'A']
Out[39]: 0.80524402538637851
```

你不用通过只想传递元组的第一个元素来指定`MultiIndex`的所有级别。例如，你可以用`df.loc['bar']`来得到`bar`这一列第一个级别的元素。

这是`df.loc[('bar',),]`的一种简写（在这个示例中等价于`df.loc['bar',]`）

"局部"切片也可以优雅的工作：

```python
In [40]: df.loc['baz':'foo']
Out[40]: 
                     A         B         C
first second                              
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
```

你可以通过传入一个元组切片来对一个数据范围进行切片：

```python
In [41]: df.loc[('baz', 'two'):('qux', 'one')]
Out[41]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466

In [42]: df.loc[('baz', 'two'):'foo']
Out[42]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
```

传入标签列表或元组会像重建索引那样工作：

```python
In [43]: df.loc[[('bar', 'two'), ('qux', 'one')]]
Out[43]: 
                     A         B         C
first second                              
bar   two     0.805244  0.813850  1.607920
qux   one    -1.170299  1.130127  0.974466
```

> 注意：在设计索引时，元组和列表在Pandas中没有被同等对待。元组被解释为一个多级别键，而列表用于指定多个键。或者说，元组是水平的（遍历级别），列表是垂直的（扫描级别）。

重要的，元组的列表索引一些完整的`MultiIndex`键，因为元组的列表指代级别中的一些值：

```python
In [44]: s = pd.Series([1, 2, 3, 4, 5, 6],
   ....:               index=pd.MultiIndex.from_product([["A", "B"], ["c", "d", "e"]]))
   ....: 

In [45]: s.loc[[("A", "c"), ("B", "d")]]  # list of tuples
Out[45]: 
A  c    1
B  d    5
dtype: int64

In [46]: s.loc[(["A", "B"], ["c", "d"])]  # tuple of lists
Out[46]: 
A  c    1
   d    2
B  c    4
   d    5
dtype: int64
```

##### 13.2.1 使用切片器

你可以通过提供多个索引器来对`MultiIndex`切片。

你可以提供任何的选择器，就像根据标签进行索引一样，查看[根据标签选择数据](https://pandas.pydata.org/pandas-docs/version/0.23/indexing.html#indexing-label)，包括切片、标签列表、标签和布尔索引器。

你可以使用`slice(None)`来选择某个级别的所有内容，不必指定所有深层级别，它们将被暗示为`slice(None)`。

通常的，切片器的两边都包含在内，因为这是标签索引。

> 警告：你应该在`.loc`符号中指定所有轴，表示索引器的行和列。 在一些不明确的情况下，传递的索引器可能被错误地解释为对两个轴都进行索引，而不是对行进行多索引 。
>
> 你应该这么用：
>
> ```python
> df.loc[(slice('A1','A3'),.....), :]
> ```
>
> 而不是这样：
>
> ```python
> df.loc[(slice('A1','A3'),.....)]
> ```

```python
In [47]: def mklbl(prefix,n):
   ....:     return ["%s%s" % (prefix,i)  for i in range(n)]
   ....: 

In [48]: miindex = pd.MultiIndex.from_product([mklbl('A',4),
   ....:                                       mklbl('B',2),
   ....:                                       mklbl('C',4),
   ....:                                       mklbl('D',2)])
   ....: 

In [49]: micolumns = pd.MultiIndex.from_tuples([('a','foo'),('a','bar'),
   ....:                                        ('b','foo'),('b','bah')],
   ....:                                       names=['lvl0', 'lvl1'])
   ....: 

In [50]: dfmi = pd.DataFrame(np.arange(len(miindex)*len(micolumns)).reshape((len(miindex),len(micolumns))),
   ....:                     index=miindex,
   ....:                     columns=micolumns).sort_index().sort_index(axis=1)
   ....: 

In [51]: dfmi
Out[51]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A0 B0 C0 D0    1    0    3    2
         D1    5    4    7    6
      C1 D0    9    8   11   10
         D1   13   12   15   14
      C2 D0   17   16   19   18
         D1   21   20   23   22
      C3 D0   25   24   27   26
...          ...  ...  ...  ...
A3 B1 C0 D1  229  228  231  230
      C1 D0  233  232  235  234
         D1  237  236  239  238
      C2 D0  241  240  243  242
         D1  245  244  247  246
      C3 D0  249  248  251  250
         D1  253  252  255  254

[64 rows x 4 columns]
```

基本的使用切片、列表和标签进行多索引切片：

```pyhton
In [52]: dfmi.loc[(slice('A1','A3'), slice(None), ['C1', 'C3']), :]
Out[52]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A1 B0 C1 D0   73   72   75   74
         D1   77   76   79   78
      C3 D0   89   88   91   90
         D1   93   92   95   94
   B1 C1 D0  105  104  107  106
         D1  109  108  111  110
      C3 D0  121  120  123  122
...          ...  ...  ...  ...
A3 B0 C1 D1  205  204  207  206
      C3 D0  217  216  219  218
         D1  221  220  223  222
   B1 C1 D0  233  232  235  234
         D1  237  236  239  238
      C3 D0  249  248  251  250
         D1  253  252  255  254

[24 rows x 4 columns]
```

你可以使用[pandas.IndexSlice](https://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.IndexSlice.html#pandas.IndexSlice)来使用`:`而不是`slice(None)`获得一种更自然便捷的语法：

```python
In [53]: idx = pd.IndexSlice

In [54]: dfmi.loc[idx[:, :, ['C1', 'C3']], idx[:, 'foo']]
Out[54]: 
lvl0           a    b
lvl1         foo  foo
A0 B0 C1 D0    8   10
         D1   12   14
      C3 D0   24   26
         D1   28   30
   B1 C1 D0   40   42
         D1   44   46
      C3 D0   56   58
...          ...  ...
A3 B0 C1 D1  204  206
      C3 D0  216  218
         D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254

[32 rows x 2 columns]
```

使用这个方法可以同时在多个轴上进行非常复杂的选择：

```python
In [55]: dfmi.loc['A1', (slice(None), 'foo')]
Out[55]: 
lvl0        a    b
lvl1      foo  foo
B0 C0 D0   64   66
      D1   68   70
   C1 D0   72   74
      D1   76   78
   C2 D0   80   82
      D1   84   86
   C3 D0   88   90
...       ...  ...
B1 C0 D1  100  102
   C1 D0  104  106
      D1  108  110
   C2 D0  112  114
      D1  116  118
   C3 D0  120  122
      D1  124  126

[16 rows x 2 columns]

In [56]: dfmi.loc[idx[:, :, ['C1', 'C3']], idx[:, 'foo']]
Out[56]: 
lvl0           a    b
lvl1         foo  foo
A0 B0 C1 D0    8   10
         D1   12   14
      C3 D0   24   26
         D1   28   30
   B1 C1 D0   40   42
         D1   44   46
      C3 D0   56   58
...          ...  ...
A3 B0 C1 D1  204  206
      C3 D0  216  218
         D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254

[32 rows x 2 columns]
```

使用布尔索引器，你可以提供与值相关的选择：

```python
In [57]: mask = dfmi[('a', 'foo')] > 200

In [58]: dfmi.loc[idx[mask, :, ['C1', 'C3']], idx[:, 'foo']]
Out[58]: 
lvl0           a    b
lvl1         foo  foo
A3 B0 C1 D1  204  206
      C3 D0  216  218
         D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254
```

 你还可以指定`.loc`的`axis`参数来解释单个轴上传递的切片器 :

```python
In [59]: dfmi.loc(axis=0)[:, :, ['C1', 'C3']]
Out[59]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A0 B0 C1 D0    9    8   11   10
         D1   13   12   15   14
      C3 D0   25   24   27   26
         D1   29   28   31   30
   B1 C1 D0   41   40   43   42
         D1   45   44   47   46
      C3 D0   57   56   59   58
...          ...  ...  ...  ...
A3 B0 C1 D1  205  204  207  206
      C3 D0  217  216  219  218
         D1  221  220  223  222
   B1 C1 D0  233  232  235  234
         D1  237  236  239  238
      C3 D0  249  248  251  250
         D1  253  252  255  254

[32 rows x 4 columns]
```

更多的，你可以用下面的方法设置数值：

```python
In [60]: df2 = dfmi.copy()

In [61]: df2.loc(axis=0)[:, :, ['C1', 'C3']] = -10

In [62]: df2
Out[62]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A0 B0 C0 D0    1    0    3    2
         D1    5    4    7    6
      C1 D0  -10  -10  -10  -10
         D1  -10  -10  -10  -10
      C2 D0   17   16   19   18
         D1   21   20   23   22
      C3 D0  -10  -10  -10  -10
...          ...  ...  ...  ...
A3 B1 C0 D1  229  228  231  230
      C1 D0  -10  -10  -10  -10
         D1  -10  -10  -10  -10
      C2 D0  241  240  243  242
         D1  245  244  247  246
      C3 D0  -10  -10  -10  -10
         D1  -10  -10  -10  -10

[64 rows x 4 columns]
```

你也可以使用一个对齐的对象的右侧（来设置数值）：

```python
In [63]: df2 = dfmi.copy()

In [64]: df2.loc[idx[:, :, ['C1', 'C3']], :] = df2 * 1000

In [65]: df2
Out[65]: 
lvl0              a               b        
lvl1            bar     foo     bah     foo
A0 B0 C0 D0       1       0       3       2
         D1       5       4       7       6
      C1 D0    9000    8000   11000   10000
         D1   13000   12000   15000   14000
      C2 D0      17      16      19      18
         D1      21      20      23      22
      C3 D0   25000   24000   27000   26000
...             ...     ...     ...     ...
A3 B1 C0 D1     229     228     231     230
      C1 D0  233000  232000  235000  234000
         D1  237000  236000  239000  238000
      C2 D0     241     240     243     242
         D1     245     244     247     246
      C3 D0  249000  248000  251000  250000
         D1  253000  252000  255000  254000

[64 rows x 4 columns]
```

##### 13.2.2 截面

`DataFrame`的`xs`方法带有一个`level`参数，以使得在`MultiIndex`的特定级别上选择数据更容易：

```python
In [66]: df
Out[66]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

In [67]: df.xs('one', level='second')
Out[67]: 
              A         B         C
first                              
bar    0.895717  0.410835 -1.413681
baz   -1.206412  0.132003  1.024180
foo    1.431256 -0.076467  0.875906
qux   -1.170299  1.130127  0.974466
```

```python
# using the slicers
In [68]: df.loc[(slice(None),'one'),:]
Out[68]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
baz   one    -1.206412  0.132003  1.024180
foo   one     1.431256 -0.076467  0.875906
qux   one    -1.170299  1.130127  0.974466
```

你有可以通过传入`axis`参数，用`xs()`来列上进行选择：

```python
In [69]: df = df.T

In [70]: df.xs('one', level='second', axis=1)
Out[70]: 
first       bar       baz       foo       qux
A      0.895717 -1.206412  1.431256 -1.170299
B      0.410835  0.132003 -0.076467  1.130127
C     -1.413681  1.024180  0.875906  0.974466
```

```python
# using the slicers
In [71]: df.loc[:,(slice(None),'one')]
Out[71]: 
first        bar       baz       foo       qux
second       one       one       one       one
A       0.895717 -1.206412  1.431256 -1.170299
B       0.410835  0.132003 -0.076467  1.130127
C      -1.413681  1.024180  0.875906  0.974466
```

`xs()`也允许用多个键进行选择：

```python
In [72]: df.xs(('one', 'bar'), level=('second', 'first'), axis=1)
Out[72]: 
first        bar
second       one
A       0.895717
B       0.410835
C      -1.413681
```

```python
# using the slicers
In [73]: df.loc[:,('bar','one')]
Out[73]: 
A    0.895717
B    0.410835
C   -1.413681
Name: (bar, one), dtype: float64
```

传入`drop_level=False`来保留被选择的级别：

```python
In [74]: df.xs('one', level='second', axis=1, drop_level=False)
Out[74]: 
first        bar       baz       foo       qux
second       one       one       one       one
A       0.895717 -1.206412  1.431256 -1.170299
B       0.410835  0.132003 -0.076467  1.130127
C      -1.413681  1.024180  0.875906  0.974466
```

对比`drop_level=True`的情况：

```python
In [75]: df.xs('one', level='second', axis=1, drop_level=True)
Out[75]: 
first       bar       baz       foo       qux
A      0.895717 -1.206412  1.431256 -1.170299
B      0.410835  0.132003 -0.076467  1.130127
C     -1.413681  1.024180  0.875906  0.974466
```

